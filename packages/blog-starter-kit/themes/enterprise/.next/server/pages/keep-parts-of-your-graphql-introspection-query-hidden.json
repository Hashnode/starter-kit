{"pageProps":{"post":{"slug":"keep-parts-of-your-graphql-introspection-query-hidden","url":"https://engineering.hashnode.com/keep-parts-of-your-graphql-introspection-query-hidden","brief":"Once you have created your first schema and your GraphQL server is up and running, it makes sense to implement precautions to prevent it from being compromised by bad actors. In the context of Hashnode, our GraphQL API serves our website and blogs. T...","title":"Keep parts of your GraphQL Introspection Query hidden","publishedAt":"2023-05-24T10:00:39.246Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1683820367152/f890c01d-283f-4a00-acad-34bc2d2542e4.png"},"author":{"name":"Florian Fuchs","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1675085454170/766f4dd9-9fba-4aa7-b141-ff62bba7eafe.jpeg"},"id":"646de0479098493346f6fff5","content":{"markdown":"Once you have created your first schema and your GraphQL server is up and running, it makes sense to implement precautions to prevent it from being compromised by bad actors. In the context of Hashnode, our GraphQL API serves our website and blogs. This article will explore excluding fields from an introspection request without disabling the server's discoverability feature by completely turning off the introspection queries.\n\n## The Result of Hiding Parts of the Schema on Introspection\n\nThe diagram below shows the final result of using a directive and an Apollo Server plugin to hide aspects from the incoming introspection request.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1684326033578/2eca5989-8763-4177-a1d9-65582e07d155.png align=\"center\")\n\nWe have a schema defined where multiple fields are annotated with `@hidden`. In the returned resultset of the Introspection query, we can see that all those fields are missing.\n\nLet's explore how we implemented it!\n\n## Taking a Look at GraphQL Schema Introspection\n\nGraphQL is a strongly typed query language. The schema, exposed from a GQL API, acts as a contract between the frontend and backend and defines the available operations. The server knows about the schema, as it's the place of definition. But how does the frontend get to know about the schema?\n\nThis is where one of the key features of GraphQL comes in hand: Schema introspection. Offering the introspection of a schema allows the clients to explore and learn about what's possible in a given API in terms of queries, mutations, subscriptions, fields, and types.\n\nThere are a couple of keywords to request schema introspections. A double underscore precedes all of them: `__`. A simple introspection query for all available types could look like this:\n\n```graphql\nquery {\n  __schema {\n    types {\n      name\n    }\n  }\n}\n```\n\nSounds great, right? It is, you get a kind of self-documentation for free. But what if you don't want to scream out your **whole** schema to the world? Due to the nature of GQL and the contract a schema poses, everything in your GraphQL schema will be visible to the world.\n\nHow can we hide certain aspects of our schema?\n\n* Shutting down the Introspection Query is a certain way to keep things private. This might be an option in a private API, but why would we hide the schema there? Turning off the introspection query in a public API would cause all our consumers to lose the ability to discover the schema, which is certainly not what we want. Additionally, automatic code generation is a common use case that relies on introspection.\n    \n* Removing certain fields from the introspection is another approach that may be more complex to manage but does not break every third-party consumer.\n    \n\nLet's explore how we can solve this problem by using some native GQL features as well as a specialty of Apollo Server: directives and plugins üé¨\n\n## Directives in Graphql Can Apply Custom Logic\n\nA directive in GraphQL is a decorator for parts of a schema or operation. An `@` character always precedes it. The most common and build-in directive is the `@depreacted` decorator that indicates the deprecation for a field:\n\n```graphql\ntype ExampleType {\n  oldField: String @deprecated(reason: \"Use `newField`.\")\n  newField: String\n}\n```\n\nThis shows two things:\n\n1. A directive can take an argument, e.g., `reason`.\n    \n2. A directive will always be placed after declaring a field or operation.\n    \n\nThere are multiple valid locations for a directive. For example, a directive declared with `ARGUMENT_DEFINITION` can be placed on an argument but not somewhere else within the schema.\n\n```graphql\ntype ExampleType {\n  oldField: String @argumentOnlyDirective # would throw an error \n  newField: String\n}\n```\n\nOverall, directives are neet enhancements for GQL that allow the execution of custom logic as appropriate. Things like authentication or authorization can be built easily with a directive.\n\nFor further reading, check out the [Apollo Server docs on directives](https://www.apollographql.com/docs/apollo-server/schema/directives/).\n\n## Formalizing the `@hidden` Directive\n\nIn our case, we want a directive that can be used in different places within our schema to hide things from the Introspection output. The simplest form of our directive can look something like this:\n\n```graphql\n  directive @hidden on OBJECT | FIELD_DEFINITION\n```\n\nWe want to be able to hide any `OBJECT`or `FIELD_DEFINITION`. This allows removing of various things from the schema. This can be enhanced to your own needs by adding additional valid locations.\n\n```graphql\ntype Example {\n fieldA: String!\n fieldB: String! @hidden\n} \n\ntype Query {\n getExampleOne: Example!\n getExampleHidden: Example! @hidden\n} \n\ntype Mutation {\n mutateOnExampleHidden(input: String!): Example! @hidden\n}\n```\n\nConsidering the above schema definition, our `@hidden` directive should be able to transform the schema once an introspection is requested by removing all the fields from the resultset, which are declared with the directive. The visible schema for a requesting consumer should look like this:\n\n```graphql\ntype Example {\n fieldA: String!\n} \n\ntype Query {\n getExampleOne: Example!\n}\n```\n\nCoding this out should be rather straightforward. If we find the annotation `@hidden`, we can remove the declared fields from the schema; otherwise, we return the original type.\n\n```typescript\nconst directive = getDirective(...);\n  \nif (directive) {\n return null;\n} else {\n return type;\n}\n```\n\n## Why Does the Directive Alone Not Work?\n\nExcellent, we now have a definition of our new directive and an Idea of how we want the output to be transformed. Once implemented, we can observe a weird behavior: It works on introspection but will also remove fields from the actual GraphQL results sets on incoming requests ü§Ø\n\nWhy is that?\n\nRetake a look at how we defined the directive from a custom logic point of view and consider when directives are applied.\n\nIn Apollo Server, a directive is applied by transforming the schema. So, applying the directive on server startup with the above code would remove the annotated fields from inspection and the whole schema. This is not what we want. The context provided to the transform function does not indicate the query type. Furthermore, introspection queries are handled a little differently by the Apollo Server.\n\nHow can we still achieve our goal of hiding things from the introspecting only?  \n‚û°Ô∏è Apollo plugins to the rescue üöÄ\n\n## Plugins in Apollo Server Allow You to Hook Into the Request Life Cycle\n\nApollo allows you to implement server plugins to perform custom operations in response to specific events. A plugin is a JavaScript object that implements one or more functions responding to events. Within a plugin are two major event categories: server [lifecycle events](https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#server-lifecycle-events) and [request lifecycle events](https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#request-lifecycle-events). In our case, we are interested in Request lifecycle events, as we want to respond to a certain event within the execution of an operation, e.g. a Request to our API.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1684155854681/a15bf2fc-94c6-4a0d-979a-d8522b72e651.png align=\"center\")\n\nTaking the above flow of the request lifecycle into account, we can see an option to hook into the returned result before the actual execution starts, in that we write a plugin that will provide its result within the `responseForOperation` hook.\n\nTaking a look into the definition of the hook, we can also confirm this above observation\n\n> The `responseForOperation` event is fired immediately before GraphQL execution would take place. If its return value resolves to a non-null `GraphQLResponse`, that result is used instead of executing the query. Hooks from different plugins are invoked in series, and the first non-null response is used.\n\nIn this hook, we have various information at our disposal to decide if we want the normal resolver flow to be invoked or if we want to do a kind of *early exit* without resolving the given fields:\n\n```typescript\nresponseForOperation?(\n requestContext:WithRequired<GraphQLRequestContext<TContext>,\n 'source' | 'queryHash' | 'document' | 'operationName' |'operation'\n): Promise<GraphQLResponse | null>;\n```\n\nWithin the `requestContxt` we find the information about which `query` was sent to the server and the operation name, and we get our hands on the whole schema that will be used for executing the request.\n\nLet's use this to combine our custom directive with a custom plugin that will hide aspects of our schema from introspection requests.\n\n## An Implementation Tells More Than 1000 Words!\n\nOverall, we have now discovered a couple of things we can make use of:\n\n* Our directive will transform a schema and remove everything annotated with `@hidden`\n    \n* We can hook into the request execution lifecycle by providing a custom plugin\n    \n* `responseForOperation` that allows us to provide a different result and skip the normal resolver execution for a request\n    \n* Within the `requestContext` we have all the information, which is also available for the normal execution of the request, to generate our result for a request\n    \n\nThe main idea is to hook into the request execution and check if we are receiving an introspection of the schema. With the information provided by `responseForOperation` and the option to directly provided a result here, we can skip the actual execution and provide a different result. This is where we can apply our hidden directive to transform the schema and remove everything annotated with `@hidden`. We will now use this updated schema **only** if we receive an introspection for further execution of the request.\n\nLet's take a look at the implementation of the plugin and directive!\n\n### The `@hidden` Directive\n\nThe directive consists of the code snippets from above and some more checks. The result of the function we are defining here is a `transformer` that will change the schema. It takes a GraphQL schema as input and will return one.\n\n```typescript\nimport { getDirective, MapperKind, mapSchema } from '@graphql-tools/utils';\nimport { gql } from 'graphql-tag';\nimport { GraphQLSchema } from 'graphql';\n\ntype DirectiveTransformer = (schema: GraphQLSchema) => GraphQLSchema;\n\n\nexport const hiddenDirectiveTypeDefs = gql`\n  directive @hidden on OBJECT | FIELD_DEFINITION\n`;\n/**\n * This directive transformer removes all types and fields that are marked with the @hidden directive from introspection queries only\n */\nexport const hiddenDirectiveTransformer: DirectiveTransformer = (schema) => {\n  const directiveName = 'hidden';\n\n  return mapSchema(schema, {\n    [MapperKind.TYPE]: (type) => {\n      const directive = getDirective(schema, type, directiveName)?.[0];\n      if (directive) {\n        return null;\n      } else {\n        return type;\n      }\n    },\n    [MapperKind.OBJECT_FIELD]: (fieldConfig) => {\n      const directive = getDirective(schema, fieldConfig, directiveName)?.[0];\n      if (directive) {\n        return null;\n      } else {\n        return fieldConfig;\n      }\n    }\n  });\n};\n```\n\nThe above code will take the schema and find all occurrences of `hidden`. Then, we check if it's defined in the right place and apply our custom logic to it. The logic will either remove the `fieldConfig` or the `type` from the schema if the directive was found. Otherwise, it will return the original definition and not change the schema.\n\n### The Apollo Server Plugin\n\nOur server plugin will now use `requestDidStart` lifecycle and the `responseForOperation` event. We need a way to identify if we are receiving an introspection query. For this, let's add a simple regex to check if the query contains at least one of the introspection keywords.\n\n```typescript\nconst REGEX_INTROSPECTION_QUERY = /\\b(__schema|__type|__typename)\\b/;\n```\n\nWe can now identify if we receive an introspection request to our schema or if it's a normal operation without any introspection parts.\n\nSo, let's bring everything together and write our custom plugin to apply our directive once we receive a schema introspection:\n\nFirst, we want to check if the plugin is being executed in the `production` environment in `development`we want full access to the schema and the playground. By returning `null`we can tell Apollo that we don't want to provide our own result for the specific query, and the execution flow should be run normally.\n\n```typescript\n// only on production\nif (!isProd) return null;\n```\n\nSecondly, we check if the query is an actual introspection request by checking the operation name (playgrounds often send a named query called `IntrospectionQuery` to the sever) or if it includes any reserved keywords that are part of the schema introspection.\n\n```typescript\nconst isIntrospectionQuery =\n ctx.request.operationName === 'IntrospectionQuery' ||\n ctx.request.query?.includes('IntrospectionQuery');\n\nconst hasIntrospectionParts =\n isIntrospectionQuery ||\n REGEX_INTROSPECTION_QUERY.test(ctx.request.query || '');\n```\n\nIf we determine this to be true, we take the original schema and pass it to the `hiddenDirectiveTransformer,` which will clean our schema from everything we don't want to include within the introspection result.\n\n```typescript\nconst schema = hiddenDirectiveTransformer(ctx?.schema);\nconst result = await execute({\n schema: schema,\n document,\n contextValue: ctx.contextValue,\n variableValues: request.variables,\n operationName: request.operationName\n});\n```\n\nThe last step is executing the actual introspection request by calling the `execute` function provided by the `graphql` package.\n\nNow we can create the response to the request by copying everything from the initial request and overriding the body:\n\n```typescript\nconst response: GraphQLResponse = {\n ...ctx.response,\n body: {\n  kind: 'single',\n  singleResult: {\n   ...result\n  }\n }\n};\n```\n\nAnd that's it. Piercing every part together, our plugin now looks like this:\n\n```typescript\ntype PluginDefinition = ApolloServerPlugin<Context>;\n\nexport const introspectionPlugin: (isProd: boolean) => PluginDefinition = (\n  isProd\n) => ({\n  async requestDidStart() {\n    return {\n      // This event is fired immediately before GraphQL execution \n      //takes place\n      async responseForOperation(ctx) {\n        // only on production\n        if (!isProd) return null;\n\n        const isIntrospectionQuery =\n          ctx.request.operationName === 'IntrospectionQuery' ||\n          ctx.request.query?.includes('IntrospectionQuery');\n\n        const hasIntrospectionParts =\n          isIntrospectionQuery ||\n          REGEX_INTROSPECTION_QUERY.test(ctx.request.query || '');\n        // If it's an introspection query, we need to apply the hidden \n        // directive transformer ourself\n        // otherwise, let Apollo handle the request by returning null\n        if (hasIntrospectionParts) {\n          const { request, document } = ctx;\n\n          // APPLY @hidden\n          const schema = hiddenDirectiveTransformer(ctx?.schema);\n          // Executing the request \n          const result = await execute({\n            schema: schema,\n            document,\n            contextValue: ctx.contextValue,\n            variableValues: request.variables,\n            operationName: request.operationName\n          });\n\n          // Setting the result\n          const response: GraphQLResponse = {\n            ...ctx.response,\n            body: {\n              kind: 'single',\n              singleResult: {\n                ...result\n              }\n            }\n          };\n          return response;\n        }\n        return null;\n      }\n    };\n  }\n});\n```\n\nNow we can apply our directive type definitions to our base schema and add our plugin to the Apollo Server - let's see how it works out üëÄ\n\n### Let‚Äôs Test It Out üöÄ\n\nTo check if everything works as expected, we will again use our simple schema to verify our implementation.\n\n```graphql\ntype Example {\n fieldA: String!\n fieldB: String! @hidden\n} \n\ntype Query {\n getExampleOne: Example!\n getExampleHidden: Example! @hidden\n} \n\ntype Mutation {\n mutateOnExampleHidden(input: String!): Example! @hidden\n}\n```\n\nLet's request a simple introspection query that checks for all fields on `query` and `mutation` as well as specifically requesting the `Example` type from our schema.\n\n```graphql\nquery {\n  __schema {\n    queryType {\n      name\n      fields {\n        name\n      }\n    }\n    mutationType {\n      name\n      fields {\n        name\n      }\n    }\n  }\n  __type(name: \"Example\") {\n    fields {\n      name\n    }\n  }\n}\n```\n\nRunning this in our `development` environment will return the following result:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1683896081794/c38c8cb5-3c03-45cf-a2bc-7342a861f535.png align=\"center\")\n\nAll the fields are there, even though some are annotated with `@hidden` as we are not running in production.\n\nNow repeat this in our `production` environment, and we see the following result:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1683896198367/7ac9a738-055b-40c8-b8fc-e3b46c74f710.png align=\"center\")\n\nYeah üéâ We have successfully omitted the fields we don't want to be part of a public introspection request to our server ü™Ñ\n\n## Takeaways\n\nNow let's revisit what we implemented here and what implications we have.\n\nFirst, this is, by no means, a safeguard for your server. Even if we omit certain fields and types from the introspection response, they are still part of the schema and will be available normally. Rather see it as making it a little harder and not as obvious for your consumers that some `private` things exist in your schema. Overall, the best way of thinking is always that everybody can see everything in GraphQL, and you should design your schema and security following this thought.\n\nSecondly, you must ensure that any reference to other definitions you have made must also be hidden. Take a look at the following code snippet:\n\n```graphql\ntype ThisIsHidden @hidden {\nfieldOther: String!\n}\n\ntype Example {\n fieldA: String!\n fieldB: String!\n fieldC: ThisIsHidden!\n} \n\ntype Query {\n getExampleOne: Example!\n getExampleHidden: Example! @hidden\n} \n\ntype Mutation {\n mutateOnExampleHidden(input: String!): Example! @hidden\n}\n```\n\nIf we now make an introspection query, this will fail, as we have removed the definition of `ThisIsHidden` from our schema but still referring to it in the `Example` type. Some third-party tools may break due to the missing reference. An easy fix is to add: `fieldC: ThisIsHidden! @hidden`. Still, you need to take care of this yourself.\n\nAlways double-check if you are not breaking other tools that are relying on your schema by carelessly using the hidden directive üôå\n\nAlright, that's it about hiding things from Introspection queries to your Server - I hope you enjoyed the read üëã","html":"<p>Once you have created your first schema and your GraphQL server is up and running, it makes sense to implement precautions to prevent it from being compromised by bad actors. In the context of Hashnode, our GraphQL API serves our website and blogs. This article will explore excluding fields from an introspection request without disabling the server's discoverability feature by completely turning off the introspection queries.</p>\n<h2 id=\"heading-the-result-of-hiding-parts-of-the-schema-on-introspection\">The Result of Hiding Parts of the Schema on Introspection</h2>\n<p>The diagram below shows the final result of using a directive and an Apollo Server plugin to hide aspects from the incoming introspection request.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1684326033578/2eca5989-8763-4177-a1d9-65582e07d155.png\" alt class=\"image--center mx-auto\" /></p>\n<p>We have a schema defined where multiple fields are annotated with <code>@hidden</code>. In the returned resultset of the Introspection query, we can see that all those fields are missing.</p>\n<p>Let's explore how we implemented it!</p>\n<h2 id=\"heading-taking-a-look-at-graphql-schema-introspection\">Taking a Look at GraphQL Schema Introspection</h2>\n<p>GraphQL is a strongly typed query language. The schema, exposed from a GQL API, acts as a contract between the frontend and backend and defines the available operations. The server knows about the schema, as it's the place of definition. But how does the frontend get to know about the schema?</p>\n<p>This is where one of the key features of GraphQL comes in hand: Schema introspection. Offering the introspection of a schema allows the clients to explore and learn about what's possible in a given API in terms of queries, mutations, subscriptions, fields, and types.</p>\n<p>There are a couple of keywords to request schema introspections. A double underscore precedes all of them: <code>__</code>. A simple introspection query for all available types could look like this:</p>\n<pre><code class=\"lang-graphql\"><span class=\"hljs-keyword\">query</span> {\n  __schema {\n    types {\n      name\n    }\n  }\n}\n</code></pre>\n<p>Sounds great, right? It is, you get a kind of self-documentation for free. But what if you don't want to scream out your <strong>whole</strong> schema to the world? Due to the nature of GQL and the contract a schema poses, everything in your GraphQL schema will be visible to the world.</p>\n<p>How can we hide certain aspects of our schema?</p>\n<ul>\n<li><p>Shutting down the Introspection Query is a certain way to keep things private. This might be an option in a private API, but why would we hide the schema there? Turning off the introspection query in a public API would cause all our consumers to lose the ability to discover the schema, which is certainly not what we want. Additionally, automatic code generation is a common use case that relies on introspection.</p>\n</li>\n<li><p>Removing certain fields from the introspection is another approach that may be more complex to manage but does not break every third-party consumer.</p>\n</li>\n</ul>\n<p>Let's explore how we can solve this problem by using some native GQL features as well as a specialty of Apollo Server: directives and plugins üé¨</p>\n<h2 id=\"heading-directives-in-graphql-can-apply-custom-logic\">Directives in Graphql Can Apply Custom Logic</h2>\n<p>A directive in GraphQL is a decorator for parts of a schema or operation. An <code>@</code> character always precedes it. The most common and build-in directive is the <code>@depreacted</code> decorator that indicates the deprecation for a field:</p>\n<pre><code class=\"lang-graphql\"><span class=\"hljs-keyword\">type</span> ExampleType {\n  <span class=\"hljs-symbol\">oldField:</span> String <span class=\"hljs-meta\">@deprecated</span>(<span class=\"hljs-symbol\">reason:</span> <span class=\"hljs-string\">\"Use `newField`.\"</span>)\n  <span class=\"hljs-symbol\">newField:</span> String\n}\n</code></pre>\n<p>This shows two things:</p>\n<ol>\n<li><p>A directive can take an argument, e.g., <code>reason</code>.</p>\n</li>\n<li><p>A directive will always be placed after declaring a field or operation.</p>\n</li>\n</ol>\n<p>There are multiple valid locations for a directive. For example, a directive declared with <code>ARGUMENT_DEFINITION</code> can be placed on an argument but not somewhere else within the schema.</p>\n<pre><code class=\"lang-graphql\"><span class=\"hljs-keyword\">type</span> ExampleType {\n  <span class=\"hljs-symbol\">oldField:</span> String <span class=\"hljs-meta\">@argumentOnlyDirective</span> <span class=\"hljs-comment\"># would throw an error </span>\n  <span class=\"hljs-symbol\">newField:</span> String\n}\n</code></pre>\n<p>Overall, directives are neet enhancements for GQL that allow the execution of custom logic as appropriate. Things like authentication or authorization can be built easily with a directive.</p>\n<p>For further reading, check out the <a target=\"_blank\" href=\"https://www.apollographql.com/docs/apollo-server/schema/directives/\">Apollo Server docs on directives</a>.</p>\n<h2 id=\"heading-formalizing-the-hidden-directive\">Formalizing the <code>@hidden</code> Directive</h2>\n<p>In our case, we want a directive that can be used in different places within our schema to hide things from the Introspection output. The simplest form of our directive can look something like this:</p>\n<pre><code class=\"lang-graphql\">  directive <span class=\"hljs-meta\">@hidden</span> <span class=\"hljs-keyword\">on</span> OBJECT | FIELD_DEFINITION\n</code></pre>\n<p>We want to be able to hide any <code>OBJECT</code>or <code>FIELD_DEFINITION</code>. This allows removing of various things from the schema. This can be enhanced to your own needs by adding additional valid locations.</p>\n<pre><code class=\"lang-graphql\"><span class=\"hljs-keyword\">type</span> Example {\n <span class=\"hljs-symbol\">fieldA:</span> String!\n <span class=\"hljs-symbol\">fieldB:</span> String! <span class=\"hljs-meta\">@hidden</span>\n} \n\n<span class=\"hljs-keyword\">type</span> Query {\n <span class=\"hljs-symbol\">getExampleOne:</span> Example!\n <span class=\"hljs-symbol\">getExampleHidden:</span> Example! <span class=\"hljs-meta\">@hidden</span>\n} \n\n<span class=\"hljs-keyword\">type</span> Mutation {\n mutateOnExampleHidden(<span class=\"hljs-symbol\">input:</span> String!): Example! <span class=\"hljs-meta\">@hidden</span>\n}\n</code></pre>\n<p>Considering the above schema definition, our <code>@hidden</code> directive should be able to transform the schema once an introspection is requested by removing all the fields from the resultset, which are declared with the directive. The visible schema for a requesting consumer should look like this:</p>\n<pre><code class=\"lang-graphql\"><span class=\"hljs-keyword\">type</span> Example {\n <span class=\"hljs-symbol\">fieldA:</span> String!\n} \n\n<span class=\"hljs-keyword\">type</span> Query {\n <span class=\"hljs-symbol\">getExampleOne:</span> Example!\n}\n</code></pre>\n<p>Coding this out should be rather straightforward. If we find the annotation <code>@hidden</code>, we can remove the declared fields from the schema; otherwise, we return the original type.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">const</span> directive = getDirective(...);\n\n<span class=\"hljs-keyword\">if</span> (directive) {\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n} <span class=\"hljs-keyword\">else</span> {\n <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">type</span>;\n}\n</code></pre>\n<h2 id=\"heading-why-does-the-directive-alone-not-work\">Why Does the Directive Alone Not Work?</h2>\n<p>Excellent, we now have a definition of our new directive and an Idea of how we want the output to be transformed. Once implemented, we can observe a weird behavior: It works on introspection but will also remove fields from the actual GraphQL results sets on incoming requests ü§Ø</p>\n<p>Why is that?</p>\n<p>Retake a look at how we defined the directive from a custom logic point of view and consider when directives are applied.</p>\n<p>In Apollo Server, a directive is applied by transforming the schema. So, applying the directive on server startup with the above code would remove the annotated fields from inspection and the whole schema. This is not what we want. The context provided to the transform function does not indicate the query type. Furthermore, introspection queries are handled a little differently by the Apollo Server.</p>\n<p>How can we still achieve our goal of hiding things from the introspecting only?<br />‚û°Ô∏è Apollo plugins to the rescue üöÄ</p>\n<h2 id=\"heading-plugins-in-apollo-server-allow-you-to-hook-into-the-request-life-cycle\">Plugins in Apollo Server Allow You to Hook Into the Request Life Cycle</h2>\n<p>Apollo allows you to implement server plugins to perform custom operations in response to specific events. A plugin is a JavaScript object that implements one or more functions responding to events. Within a plugin are two major event categories: server <a target=\"_blank\" href=\"https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#server-lifecycle-events\">lifecycle events</a> and <a target=\"_blank\" href=\"https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#request-lifecycle-events\">request lifecycle events</a>. In our case, we are interested in Request lifecycle events, as we want to respond to a certain event within the execution of an operation, e.g. a Request to our API.</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1684155854681/a15bf2fc-94c6-4a0d-979a-d8522b72e651.png\" alt class=\"image--center mx-auto\" /></p>\n<p>Taking the above flow of the request lifecycle into account, we can see an option to hook into the returned result before the actual execution starts, in that we write a plugin that will provide its result within the <code>responseForOperation</code> hook.</p>\n<p>Taking a look into the definition of the hook, we can also confirm this above observation</p>\n<blockquote>\n<p>The <code>responseForOperation</code> event is fired immediately before GraphQL execution would take place. If its return value resolves to a non-null <code>GraphQLResponse</code>, that result is used instead of executing the query. Hooks from different plugins are invoked in series, and the first non-null response is used.</p>\n</blockquote>\n<p>In this hook, we have various information at our disposal to decide if we want the normal resolver flow to be invoked or if we want to do a kind of <em>early exit</em> without resolving the given fields:</p>\n<pre><code class=\"lang-typescript\">responseForOperation?(\n requestContext:WithRequired&lt;GraphQLRequestContext&lt;TContext&gt;,\n <span class=\"hljs-string\">'source'</span> | <span class=\"hljs-string\">'queryHash'</span> | <span class=\"hljs-string\">'document'</span> | <span class=\"hljs-string\">'operationName'</span> |<span class=\"hljs-string\">'operation'</span>\n): <span class=\"hljs-built_in\">Promise</span>&lt;GraphQLResponse | <span class=\"hljs-literal\">null</span>&gt;;\n</code></pre>\n<p>Within the <code>requestContxt</code> we find the information about which <code>query</code> was sent to the server and the operation name, and we get our hands on the whole schema that will be used for executing the request.</p>\n<p>Let's use this to combine our custom directive with a custom plugin that will hide aspects of our schema from introspection requests.</p>\n<h2 id=\"heading-an-implementation-tells-more-than-1000-words\">An Implementation Tells More Than 1000 Words!</h2>\n<p>Overall, we have now discovered a couple of things we can make use of:</p>\n<ul>\n<li><p>Our directive will transform a schema and remove everything annotated with <code>@hidden</code></p>\n</li>\n<li><p>We can hook into the request execution lifecycle by providing a custom plugin</p>\n</li>\n<li><p><code>responseForOperation</code> that allows us to provide a different result and skip the normal resolver execution for a request</p>\n</li>\n<li><p>Within the <code>requestContext</code> we have all the information, which is also available for the normal execution of the request, to generate our result for a request</p>\n</li>\n</ul>\n<p>The main idea is to hook into the request execution and check if we are receiving an introspection of the schema. With the information provided by <code>responseForOperation</code> and the option to directly provided a result here, we can skip the actual execution and provide a different result. This is where we can apply our hidden directive to transform the schema and remove everything annotated with <code>@hidden</code>. We will now use this updated schema <strong>only</strong> if we receive an introspection for further execution of the request.</p>\n<p>Let's take a look at the implementation of the plugin and directive!</p>\n<h3 id=\"heading-the-hidden-directive\">The <code>@hidden</code> Directive</h3>\n<p>The directive consists of the code snippets from above and some more checks. The result of the function we are defining here is a <code>transformer</code> that will change the schema. It takes a GraphQL schema as input and will return one.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">import</span> { getDirective, MapperKind, mapSchema } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@graphql-tools/utils'</span>;\n<span class=\"hljs-keyword\">import</span> { gql } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'graphql-tag'</span>;\n<span class=\"hljs-keyword\">import</span> { GraphQLSchema } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'graphql'</span>;\n\n<span class=\"hljs-keyword\">type</span> DirectiveTransformer = <span class=\"hljs-function\">(<span class=\"hljs-params\">schema: GraphQLSchema</span>) =&gt;</span> GraphQLSchema;\n\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> hiddenDirectiveTypeDefs = gql<span class=\"hljs-string\">`\n  directive @hidden on OBJECT | FIELD_DEFINITION\n`</span>;\n<span class=\"hljs-comment\">/**\n * This directive transformer removes all types and fields that are marked with the @hidden directive from introspection queries only\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> hiddenDirectiveTransformer: DirectiveTransformer = <span class=\"hljs-function\">(<span class=\"hljs-params\">schema</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> directiveName = <span class=\"hljs-string\">'hidden'</span>;\n\n  <span class=\"hljs-keyword\">return</span> mapSchema(schema, {\n    [MapperKind.TYPE]: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-keyword\">type</span></span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> directive = getDirective(schema, <span class=\"hljs-keyword\">type</span>, directiveName)?.[<span class=\"hljs-number\">0</span>];\n      <span class=\"hljs-keyword\">if</span> (directive) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">type</span>;\n      }\n    },\n    [MapperKind.OBJECT_FIELD]: <span class=\"hljs-function\">(<span class=\"hljs-params\">fieldConfig</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> directive = getDirective(schema, fieldConfig, directiveName)?.[<span class=\"hljs-number\">0</span>];\n      <span class=\"hljs-keyword\">if</span> (directive) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> fieldConfig;\n      }\n    }\n  });\n};\n</code></pre>\n<p>The above code will take the schema and find all occurrences of <code>hidden</code>. Then, we check if it's defined in the right place and apply our custom logic to it. The logic will either remove the <code>fieldConfig</code> or the <code>type</code> from the schema if the directive was found. Otherwise, it will return the original definition and not change the schema.</p>\n<h3 id=\"heading-the-apollo-server-plugin\">The Apollo Server Plugin</h3>\n<p>Our server plugin will now use <code>requestDidStart</code> lifecycle and the <code>responseForOperation</code> event. We need a way to identify if we are receiving an introspection query. For this, let's add a simple regex to check if the query contains at least one of the introspection keywords.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">const</span> REGEX_INTROSPECTION_QUERY = <span class=\"hljs-regexp\">/\\b(__schema|__type|__typename)\\b/</span>;\n</code></pre>\n<p>We can now identify if we receive an introspection request to our schema or if it's a normal operation without any introspection parts.</p>\n<p>So, let's bring everything together and write our custom plugin to apply our directive once we receive a schema introspection:</p>\n<p>First, we want to check if the plugin is being executed in the <code>production</code> environment in <code>development</code>we want full access to the schema and the playground. By returning <code>null</code>we can tell Apollo that we don't want to provide our own result for the specific query, and the execution flow should be run normally.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-comment\">// only on production</span>\n<span class=\"hljs-keyword\">if</span> (!isProd) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n</code></pre>\n<p>Secondly, we check if the query is an actual introspection request by checking the operation name (playgrounds often send a named query called <code>IntrospectionQuery</code> to the sever) or if it includes any reserved keywords that are part of the schema introspection.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">const</span> isIntrospectionQuery =\n ctx.request.operationName === <span class=\"hljs-string\">'IntrospectionQuery'</span> ||\n ctx.request.query?.includes(<span class=\"hljs-string\">'IntrospectionQuery'</span>);\n\n<span class=\"hljs-keyword\">const</span> hasIntrospectionParts =\n isIntrospectionQuery ||\n REGEX_INTROSPECTION_QUERY.test(ctx.request.query || <span class=\"hljs-string\">''</span>);\n</code></pre>\n<p>If we determine this to be true, we take the original schema and pass it to the <code>hiddenDirectiveTransformer,</code> which will clean our schema from everything we don't want to include within the introspection result.</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">const</span> schema = hiddenDirectiveTransformer(ctx?.schema);\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> execute({\n schema: schema,\n <span class=\"hljs-built_in\">document</span>,\n contextValue: ctx.contextValue,\n variableValues: request.variables,\n operationName: request.operationName\n});\n</code></pre>\n<p>The last step is executing the actual introspection request by calling the <code>execute</code> function provided by the <code>graphql</code> package.</p>\n<p>Now we can create the response to the request by copying everything from the initial request and overriding the body:</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">const</span> response: GraphQLResponse = {\n ...ctx.response,\n body: {\n  kind: <span class=\"hljs-string\">'single'</span>,\n  singleResult: {\n   ...result\n  }\n }\n};\n</code></pre>\n<p>And that's it. Piercing every part together, our plugin now looks like this:</p>\n<pre><code class=\"lang-typescript\"><span class=\"hljs-keyword\">type</span> PluginDefinition = ApolloServerPlugin&lt;Context&gt;;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> introspectionPlugin: <span class=\"hljs-function\">(<span class=\"hljs-params\">isProd: <span class=\"hljs-built_in\">boolean</span></span>) =&gt;</span> PluginDefinition = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  isProd\n</span>) =&gt;</span> ({\n  <span class=\"hljs-keyword\">async</span> requestDidStart() {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-comment\">// This event is fired immediately before GraphQL execution </span>\n      <span class=\"hljs-comment\">//takes place</span>\n      <span class=\"hljs-keyword\">async</span> responseForOperation(ctx) {\n        <span class=\"hljs-comment\">// only on production</span>\n        <span class=\"hljs-keyword\">if</span> (!isProd) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n\n        <span class=\"hljs-keyword\">const</span> isIntrospectionQuery =\n          ctx.request.operationName === <span class=\"hljs-string\">'IntrospectionQuery'</span> ||\n          ctx.request.query?.includes(<span class=\"hljs-string\">'IntrospectionQuery'</span>);\n\n        <span class=\"hljs-keyword\">const</span> hasIntrospectionParts =\n          isIntrospectionQuery ||\n          REGEX_INTROSPECTION_QUERY.test(ctx.request.query || <span class=\"hljs-string\">''</span>);\n        <span class=\"hljs-comment\">// If it's an introspection query, we need to apply the hidden </span>\n        <span class=\"hljs-comment\">// directive transformer ourself</span>\n        <span class=\"hljs-comment\">// otherwise, let Apollo handle the request by returning null</span>\n        <span class=\"hljs-keyword\">if</span> (hasIntrospectionParts) {\n          <span class=\"hljs-keyword\">const</span> { request, <span class=\"hljs-built_in\">document</span> } = ctx;\n\n          <span class=\"hljs-comment\">// APPLY @hidden</span>\n          <span class=\"hljs-keyword\">const</span> schema = hiddenDirectiveTransformer(ctx?.schema);\n          <span class=\"hljs-comment\">// Executing the request </span>\n          <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> execute({\n            schema: schema,\n            <span class=\"hljs-built_in\">document</span>,\n            contextValue: ctx.contextValue,\n            variableValues: request.variables,\n            operationName: request.operationName\n          });\n\n          <span class=\"hljs-comment\">// Setting the result</span>\n          <span class=\"hljs-keyword\">const</span> response: GraphQLResponse = {\n            ...ctx.response,\n            body: {\n              kind: <span class=\"hljs-string\">'single'</span>,\n              singleResult: {\n                ...result\n              }\n            }\n          };\n          <span class=\"hljs-keyword\">return</span> response;\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n      }\n    };\n  }\n});\n</code></pre>\n<p>Now we can apply our directive type definitions to our base schema and add our plugin to the Apollo Server - let's see how it works out üëÄ</p>\n<h3 id=\"heading-lets-test-it-out\">Let‚Äôs Test It Out üöÄ</h3>\n<p>To check if everything works as expected, we will again use our simple schema to verify our implementation.</p>\n<pre><code class=\"lang-graphql\"><span class=\"hljs-keyword\">type</span> Example {\n <span class=\"hljs-symbol\">fieldA:</span> String!\n <span class=\"hljs-symbol\">fieldB:</span> String! <span class=\"hljs-meta\">@hidden</span>\n} \n\n<span class=\"hljs-keyword\">type</span> Query {\n <span class=\"hljs-symbol\">getExampleOne:</span> Example!\n <span class=\"hljs-symbol\">getExampleHidden:</span> Example! <span class=\"hljs-meta\">@hidden</span>\n} \n\n<span class=\"hljs-keyword\">type</span> Mutation {\n mutateOnExampleHidden(<span class=\"hljs-symbol\">input:</span> String!): Example! <span class=\"hljs-meta\">@hidden</span>\n}\n</code></pre>\n<p>Let's request a simple introspection query that checks for all fields on <code>query</code> and <code>mutation</code> as well as specifically requesting the <code>Example</code> type from our schema.</p>\n<pre><code class=\"lang-graphql\"><span class=\"hljs-keyword\">query</span> {\n  __schema {\n    queryType {\n      name\n      fields {\n        name\n      }\n    }\n    mutationType {\n      name\n      fields {\n        name\n      }\n    }\n  }\n  __type(<span class=\"hljs-symbol\">name:</span> <span class=\"hljs-string\">\"Example\"</span>) {\n    fields {\n      name\n    }\n  }\n}\n</code></pre>\n<p>Running this in our <code>development</code> environment will return the following result:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1683896081794/c38c8cb5-3c03-45cf-a2bc-7342a861f535.png\" alt class=\"image--center mx-auto\" /></p>\n<p>All the fields are there, even though some are annotated with <code>@hidden</code> as we are not running in production.</p>\n<p>Now repeat this in our <code>production</code> environment, and we see the following result:</p>\n<p><img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1683896198367/7ac9a738-055b-40c8-b8fc-e3b46c74f710.png\" alt class=\"image--center mx-auto\" /></p>\n<p>Yeah üéâ We have successfully omitted the fields we don't want to be part of a public introspection request to our server ü™Ñ</p>\n<h2 id=\"heading-takeaways\">Takeaways</h2>\n<p>Now let's revisit what we implemented here and what implications we have.</p>\n<p>First, this is, by no means, a safeguard for your server. Even if we omit certain fields and types from the introspection response, they are still part of the schema and will be available normally. Rather see it as making it a little harder and not as obvious for your consumers that some <code>private</code> things exist in your schema. Overall, the best way of thinking is always that everybody can see everything in GraphQL, and you should design your schema and security following this thought.</p>\n<p>Secondly, you must ensure that any reference to other definitions you have made must also be hidden. Take a look at the following code snippet:</p>\n<pre><code class=\"lang-graphql\"><span class=\"hljs-keyword\">type</span> ThisIsHidden <span class=\"hljs-meta\">@hidden</span> {\n<span class=\"hljs-symbol\">fieldOther:</span> String!\n}\n\n<span class=\"hljs-keyword\">type</span> Example {\n <span class=\"hljs-symbol\">fieldA:</span> String!\n <span class=\"hljs-symbol\">fieldB:</span> String!\n <span class=\"hljs-symbol\">fieldC:</span> ThisIsHidden!\n} \n\n<span class=\"hljs-keyword\">type</span> Query {\n <span class=\"hljs-symbol\">getExampleOne:</span> Example!\n <span class=\"hljs-symbol\">getExampleHidden:</span> Example! <span class=\"hljs-meta\">@hidden</span>\n} \n\n<span class=\"hljs-keyword\">type</span> Mutation {\n mutateOnExampleHidden(<span class=\"hljs-symbol\">input:</span> String!): Example! <span class=\"hljs-meta\">@hidden</span>\n}\n</code></pre>\n<p>If we now make an introspection query, this will fail, as we have removed the definition of <code>ThisIsHidden</code> from our schema but still referring to it in the <code>Example</code> type. Some third-party tools may break due to the missing reference. An easy fix is to add: <code>fieldC: ThisIsHidden! @hidden</code>. Still, you need to take care of this yourself.</p>\n<p>Always double-check if you are not breaking other tools that are relying on your schema by carelessly using the hidden directive üôå</p>\n<p>Alright, that's it about hiding things from Introspection queries to your Server - I hope you enjoyed the read üëã</p>\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1683897207381/cdd07204-4840-4835-a506-653677be4e3b.png"}}},"__N_SSG":true}