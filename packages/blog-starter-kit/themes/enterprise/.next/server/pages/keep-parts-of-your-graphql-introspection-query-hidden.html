<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="A statically generated blog example using Next.js and Hashnode."/><title>Keep parts of your GraphQL Introspection Query hidden | Next.js Blog Example with Hashnode</title><link rel="canonical" href="https://engineering.hashnode.com/keep-parts-of-your-graphql-introspection-query-hidden"/><meta property="og:image" content="https://cdn.hashnode.com/res/hashnode/image/upload/v1683897207381/cdd07204-4840-4835-a506-653677be4e3b.png"/><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}</style><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/d0e5352acbffda1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d0e5352acbffda1a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-1971b0cfe55b3cec.js" defer=""></script><script src="/_next/static/chunks/main-23c305297f46b9aa.js" defer=""></script><script src="/_next/static/chunks/pages/_app-578b9546cf8037d6.js" defer=""></script><script src="/_next/static/chunks/993-0855efe76f399ee1.js" defer=""></script><script src="/_next/static/chunks/209-1ad34ca62f7e8c97.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-a70486900a6d7b3c.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_buildManifest.js" defer=""></script><script src="/_next/static/0y8ML8Ut1GKcfVwKpwMCT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen bg-white dark:bg-neutral-950"><main><div class="container mx-auto undefined"><div class="grid items-center grid-cols-3 gap-10 px-5 py-10 md:grid-cols-2"><div class="col-span-1"><h2 class="text-3xl font-bold md:text-5xl text-slate-950 dark:text-neutral-100"><a href="/">Blog</a></h2></div><div class="flex flex-row justify-end col-span-2 md:col-span-1"><button class="flex flex-row items-center justify-start gap-2 px-4 py-2 text-sm font-semibold transition-colors duration-200 rounded-full border md:text-base md:px-5 md:py-3 hover:bg-primary-600 hover:text-white bg-primary-50 text-primary-600  border-primary-600 dark:bg-primary-500 dark:text-white md:justify-center undefined"><div class="flex flex-row items-center gap-2"><div class="shrink-0"><svg class="w-5 h-5 fill-current" fill="none" viewBox="0 0 24 24"><path fill="currentColor" d="M13.137 7.1a.75.75 0 1 0 0-1.5v1.5Zm6.765 5.58a.75.75 0 0 0-1.5 0h1.5Zm-17.4-3.13a.75.75 0 1 0-.69 1.332l.69-1.332Zm14.092 2.155a.75.75 0 0 0-.833-1.248l.833 1.248Zm-.312-6.095a.75.75 0 0 0 0 1.5v-1.5ZM22 7.109a.75.75 0 0 0 0-1.5v1.5Zm-3.609 2.108a.75.75 0 1 0 1.5 0h-1.5Zm1.5-5.717a.75.75 0 0 0-1.5 0h1.5ZM8.277 13.377l-.344.666.344-.666Zm1.85.785.118-.74-.117.74Zm3.02-1.058-.417-.624.416.624Zm-1.752.987-.2-.723.2.723Zm7.007 3.695c0 .638-.517 1.155-1.155 1.155v1.5a2.656 2.656 0 0 0 2.655-2.655h-1.5Zm-1.155 1.155H3.906v1.5h13.34v-1.5Zm-13.341 0a1.156 1.156 0 0 1-1.156-1.155h-1.5a2.656 2.656 0 0 0 2.656 2.655v-1.5ZM2.75 17.786v-9.53h-1.5v9.53h1.5Zm0-9.53c0-.638.517-1.155 1.156-1.155V5.6A2.656 2.656 0 0 0 1.25 8.256h1.5Zm1.156-1.155h9.23V5.6h-9.23v1.5Zm15.996 10.685V12.68h-1.5v5.106h1.5ZM1.812 10.88l6.12 3.162.69-1.332-6.12-3.162-.69 1.332Zm11.75 2.847 3.032-2.024-.833-1.248-3.031 2.024.833 1.248Zm2.72-6.62h2.86v-1.5h-2.86v1.5Zm2.86 0H22v-1.5h-2.859v1.5Zm.75 2.11v-2.86h-1.5v2.86h1.5Zm0-2.86V3.5h-1.5v2.859h1.5Zm-11.96 7.685c.87.45 1.453.76 2.078.86l.235-1.482c-.33-.052-.662-.214-1.624-.71l-.688 1.332Zm4.798-1.563c-.9.601-1.213.8-1.535.888l.4 1.446c.61-.168 1.154-.543 1.968-1.086l-.833-1.248Zm-2.72 2.423a3.75 3.75 0 0 0 1.584-.09l-.399-1.445a2.257 2.257 0 0 1-.95.053l-.235 1.482Z"></path></svg></div>Subscibe for updates</div><div class="shrink-0"></div></button></div></div><article class="flex flex-col items-start gap-10 pb-10"><div class="max-w-screen-lg px-5 mx-auto prose md:prose-xl dark:prose-invert prose-h1:text-center"><h1 class="">Keep parts of your GraphQL Introspection Query hidden</h1></div><div class="flex-row items-center justify-center hidden w-full gap-5 md:flex text-slate-700 dark:text-neutral-300"><div class="flex items-center gap-2"><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1675085454170/766f4dd9-9fba-4aa7-b141-ff62bba7eafe.jpeg" class="w-10 h-10 rounded-full" alt="Florian Fuchs"/><div class="text-base font-bold text-slate-600 dark:text-neutral-300">Florian Fuchs</div></div><time dateTime="2023-05-24T10:00:39.246Z">May 24, 2023</time></div><div class="w-full px-5 sm:mx-0"><div class="sm:mx-0"><div class="relative pt-[56.25%]"><img alt="Cover Image for Keep parts of your GraphQL Introspection Query hidden" loading="lazy" decoding="async" data-nimg="fill" class="border dark:border-neutral-600 rounded-xl w-full" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;object-fit:cover;color:transparent" sizes="100vw" srcSet="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683820367152%2Ff890c01d-283f-4a00-acad-34bc2d2542e4.png&amp;w=640&amp;q=75 640w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683820367152%2Ff890c01d-283f-4a00-acad-34bc2d2542e4.png&amp;w=750&amp;q=75 750w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683820367152%2Ff890c01d-283f-4a00-acad-34bc2d2542e4.png&amp;w=828&amp;q=75 828w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683820367152%2Ff890c01d-283f-4a00-acad-34bc2d2542e4.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683820367152%2Ff890c01d-283f-4a00-acad-34bc2d2542e4.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683820367152%2Ff890c01d-283f-4a00-acad-34bc2d2542e4.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683820367152%2Ff890c01d-283f-4a00-acad-34bc2d2542e4.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683820367152%2Ff890c01d-283f-4a00-acad-34bc2d2542e4.png&amp;w=3840&amp;q=75 3840w" src="/_next/image?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1683820367152%2Ff890c01d-283f-4a00-acad-34bc2d2542e4.png&amp;w=3840&amp;q=75"/></div></div></div><div class="w-full px-5 mx-auto md:max-w-screen-md hashnode-content-style"><p>Once you have created your first schema and your GraphQL server is up and running, it makes sense to implement precautions to prevent it from being compromised by bad actors. In the context of Hashnode, our GraphQL API serves our website and blogs. This article will explore excluding fields from an introspection request without disabling the server's discoverability feature by completely turning off the introspection queries.</p>
<h2 id="heading-the-result-of-hiding-parts-of-the-schema-on-introspection">The Result of Hiding Parts of the Schema on Introspection</h2>
<p>The diagram below shows the final result of using a directive and an Apollo Server plugin to hide aspects from the incoming introspection request.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1684326033578/2eca5989-8763-4177-a1d9-65582e07d155.png" class="image--center mx-auto" /></p>
<p>We have a schema defined where multiple fields are annotated with <code>@hidden</code>. In the returned resultset of the Introspection query, we can see that all those fields are missing.</p>
<p>Let's explore how we implemented it!</p>
<h2 id="heading-taking-a-look-at-graphql-schema-introspection">Taking a Look at GraphQL Schema Introspection</h2>
<p>GraphQL is a strongly typed query language. The schema, exposed from a GQL API, acts as a contract between the frontend and backend and defines the available operations. The server knows about the schema, as it's the place of definition. But how does the frontend get to know about the schema?</p>
<p>This is where one of the key features of GraphQL comes in hand: Schema introspection. Offering the introspection of a schema allows the clients to explore and learn about what's possible in a given API in terms of queries, mutations, subscriptions, fields, and types.</p>
<p>There are a couple of keywords to request schema introspections. A double underscore precedes all of them: <code>__</code>. A simple introspection query for all available types could look like this:</p>
<pre><code class="lang-graphql"><span class="hljs-keyword">query</span> {
  __schema {
    types {
      name
    }
  }
}
</code></pre>
<p>Sounds great, right? It is, you get a kind of self-documentation for free. But what if you don't want to scream out your <strong>whole</strong> schema to the world? Due to the nature of GQL and the contract a schema poses, everything in your GraphQL schema will be visible to the world.</p>
<p>How can we hide certain aspects of our schema?</p>
<ul>
<li><p>Shutting down the Introspection Query is a certain way to keep things private. This might be an option in a private API, but why would we hide the schema there? Turning off the introspection query in a public API would cause all our consumers to lose the ability to discover the schema, which is certainly not what we want. Additionally, automatic code generation is a common use case that relies on introspection.</p>
</li>
<li><p>Removing certain fields from the introspection is another approach that may be more complex to manage but does not break every third-party consumer.</p>
</li>
</ul>
<p>Let's explore how we can solve this problem by using some native GQL features as well as a specialty of Apollo Server: directives and plugins üé¨</p>
<h2 id="heading-directives-in-graphql-can-apply-custom-logic">Directives in Graphql Can Apply Custom Logic</h2>
<p>A directive in GraphQL is a decorator for parts of a schema or operation. An <code>@</code> character always precedes it. The most common and build-in directive is the <code>@depreacted</code> decorator that indicates the deprecation for a field:</p>
<pre><code class="lang-graphql"><span class="hljs-keyword">type</span> ExampleType {
  <span class="hljs-symbol">oldField:</span> String <span class="hljs-meta">@deprecated</span>(<span class="hljs-symbol">reason:</span> <span class="hljs-string">"Use `newField`."</span>)
  <span class="hljs-symbol">newField:</span> String
}
</code></pre>
<p>This shows two things:</p>
<ol>
<li><p>A directive can take an argument, e.g., <code>reason</code>.</p>
</li>
<li><p>A directive will always be placed after declaring a field or operation.</p>
</li>
</ol>
<p>There are multiple valid locations for a directive. For example, a directive declared with <code>ARGUMENT_DEFINITION</code> can be placed on an argument but not somewhere else within the schema.</p>
<pre><code class="lang-graphql"><span class="hljs-keyword">type</span> ExampleType {
  <span class="hljs-symbol">oldField:</span> String <span class="hljs-meta">@argumentOnlyDirective</span> <span class="hljs-comment"># would throw an error </span>
  <span class="hljs-symbol">newField:</span> String
}
</code></pre>
<p>Overall, directives are neet enhancements for GQL that allow the execution of custom logic as appropriate. Things like authentication or authorization can be built easily with a directive.</p>
<p>For further reading, check out the <a target="_blank" href="https://www.apollographql.com/docs/apollo-server/schema/directives/">Apollo Server docs on directives</a>.</p>
<h2 id="heading-formalizing-the-hidden-directive">Formalizing the <code>@hidden</code> Directive</h2>
<p>In our case, we want a directive that can be used in different places within our schema to hide things from the Introspection output. The simplest form of our directive can look something like this:</p>
<pre><code class="lang-graphql">  directive <span class="hljs-meta">@hidden</span> <span class="hljs-keyword">on</span> OBJECT | FIELD_DEFINITION
</code></pre>
<p>We want to be able to hide any <code>OBJECT</code>or <code>FIELD_DEFINITION</code>. This allows removing of various things from the schema. This can be enhanced to your own needs by adding additional valid locations.</p>
<pre><code class="lang-graphql"><span class="hljs-keyword">type</span> Example {
 <span class="hljs-symbol">fieldA:</span> String!
 <span class="hljs-symbol">fieldB:</span> String! <span class="hljs-meta">@hidden</span>
} 

<span class="hljs-keyword">type</span> Query {
 <span class="hljs-symbol">getExampleOne:</span> Example!
 <span class="hljs-symbol">getExampleHidden:</span> Example! <span class="hljs-meta">@hidden</span>
} 

<span class="hljs-keyword">type</span> Mutation {
 mutateOnExampleHidden(<span class="hljs-symbol">input:</span> String!): Example! <span class="hljs-meta">@hidden</span>
}
</code></pre>
<p>Considering the above schema definition, our <code>@hidden</code> directive should be able to transform the schema once an introspection is requested by removing all the fields from the resultset, which are declared with the directive. The visible schema for a requesting consumer should look like this:</p>
<pre><code class="lang-graphql"><span class="hljs-keyword">type</span> Example {
 <span class="hljs-symbol">fieldA:</span> String!
} 

<span class="hljs-keyword">type</span> Query {
 <span class="hljs-symbol">getExampleOne:</span> Example!
}
</code></pre>
<p>Coding this out should be rather straightforward. If we find the annotation <code>@hidden</code>, we can remove the declared fields from the schema; otherwise, we return the original type.</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> directive = getDirective(...);

<span class="hljs-keyword">if</span> (directive) {
 <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
} <span class="hljs-keyword">else</span> {
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>;
}
</code></pre>
<h2 id="heading-why-does-the-directive-alone-not-work">Why Does the Directive Alone Not Work?</h2>
<p>Excellent, we now have a definition of our new directive and an Idea of how we want the output to be transformed. Once implemented, we can observe a weird behavior: It works on introspection but will also remove fields from the actual GraphQL results sets on incoming requests ü§Ø</p>
<p>Why is that?</p>
<p>Retake a look at how we defined the directive from a custom logic point of view and consider when directives are applied.</p>
<p>In Apollo Server, a directive is applied by transforming the schema. So, applying the directive on server startup with the above code would remove the annotated fields from inspection and the whole schema. This is not what we want. The context provided to the transform function does not indicate the query type. Furthermore, introspection queries are handled a little differently by the Apollo Server.</p>
<p>How can we still achieve our goal of hiding things from the introspecting only?<br />‚û°Ô∏è Apollo plugins to the rescue üöÄ</p>
<h2 id="heading-plugins-in-apollo-server-allow-you-to-hook-into-the-request-life-cycle">Plugins in Apollo Server Allow You to Hook Into the Request Life Cycle</h2>
<p>Apollo allows you to implement server plugins to perform custom operations in response to specific events. A plugin is a JavaScript object that implements one or more functions responding to events. Within a plugin are two major event categories: server <a target="_blank" href="https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#server-lifecycle-events">lifecycle events</a> and <a target="_blank" href="https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#request-lifecycle-events">request lifecycle events</a>. In our case, we are interested in Request lifecycle events, as we want to respond to a certain event within the execution of an operation, e.g. a Request to our API.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1684155854681/a15bf2fc-94c6-4a0d-979a-d8522b72e651.png" class="image--center mx-auto" /></p>
<p>Taking the above flow of the request lifecycle into account, we can see an option to hook into the returned result before the actual execution starts, in that we write a plugin that will provide its result within the <code>responseForOperation</code> hook.</p>
<p>Taking a look into the definition of the hook, we can also confirm this above observation</p>
<blockquote>
<p>The <code>responseForOperation</code> event is fired immediately before GraphQL execution would take place. If its return value resolves to a non-null <code>GraphQLResponse</code>, that result is used instead of executing the query. Hooks from different plugins are invoked in series, and the first non-null response is used.</p>
</blockquote>
<p>In this hook, we have various information at our disposal to decide if we want the normal resolver flow to be invoked or if we want to do a kind of <em>early exit</em> without resolving the given fields:</p>
<pre><code class="lang-typescript">responseForOperation?(
 requestContext:WithRequired&lt;GraphQLRequestContext&lt;TContext&gt;,
 <span class="hljs-string">'source'</span> | <span class="hljs-string">'queryHash'</span> | <span class="hljs-string">'document'</span> | <span class="hljs-string">'operationName'</span> |<span class="hljs-string">'operation'</span>
): <span class="hljs-built_in">Promise</span>&lt;GraphQLResponse | <span class="hljs-literal">null</span>&gt;;
</code></pre>
<p>Within the <code>requestContxt</code> we find the information about which <code>query</code> was sent to the server and the operation name, and we get our hands on the whole schema that will be used for executing the request.</p>
<p>Let's use this to combine our custom directive with a custom plugin that will hide aspects of our schema from introspection requests.</p>
<h2 id="heading-an-implementation-tells-more-than-1000-words">An Implementation Tells More Than 1000 Words!</h2>
<p>Overall, we have now discovered a couple of things we can make use of:</p>
<ul>
<li><p>Our directive will transform a schema and remove everything annotated with <code>@hidden</code></p>
</li>
<li><p>We can hook into the request execution lifecycle by providing a custom plugin</p>
</li>
<li><p><code>responseForOperation</code> that allows us to provide a different result and skip the normal resolver execution for a request</p>
</li>
<li><p>Within the <code>requestContext</code> we have all the information, which is also available for the normal execution of the request, to generate our result for a request</p>
</li>
</ul>
<p>The main idea is to hook into the request execution and check if we are receiving an introspection of the schema. With the information provided by <code>responseForOperation</code> and the option to directly provided a result here, we can skip the actual execution and provide a different result. This is where we can apply our hidden directive to transform the schema and remove everything annotated with <code>@hidden</code>. We will now use this updated schema <strong>only</strong> if we receive an introspection for further execution of the request.</p>
<p>Let's take a look at the implementation of the plugin and directive!</p>
<h3 id="heading-the-hidden-directive">The <code>@hidden</code> Directive</h3>
<p>The directive consists of the code snippets from above and some more checks. The result of the function we are defining here is a <code>transformer</code> that will change the schema. It takes a GraphQL schema as input and will return one.</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { getDirective, MapperKind, mapSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">'@graphql-tools/utils'</span>;
<span class="hljs-keyword">import</span> { gql } <span class="hljs-keyword">from</span> <span class="hljs-string">'graphql-tag'</span>;
<span class="hljs-keyword">import</span> { GraphQLSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">'graphql'</span>;

<span class="hljs-keyword">type</span> DirectiveTransformer = <span class="hljs-function">(<span class="hljs-params">schema: GraphQLSchema</span>) =&gt;</span> GraphQLSchema;


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hiddenDirectiveTypeDefs = gql<span class="hljs-string">`
  directive @hidden on OBJECT | FIELD_DEFINITION
`</span>;
<span class="hljs-comment">/**
 * This directive transformer removes all types and fields that are marked with the @hidden directive from introspection queries only
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> hiddenDirectiveTransformer: DirectiveTransformer = <span class="hljs-function">(<span class="hljs-params">schema</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> directiveName = <span class="hljs-string">'hidden'</span>;

  <span class="hljs-keyword">return</span> mapSchema(schema, {
    [MapperKind.TYPE]: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> directive = getDirective(schema, <span class="hljs-keyword">type</span>, directiveName)?.[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">if</span> (directive) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>;
      }
    },
    [MapperKind.OBJECT_FIELD]: <span class="hljs-function">(<span class="hljs-params">fieldConfig</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> directive = getDirective(schema, fieldConfig, directiveName)?.[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">if</span> (directive) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> fieldConfig;
      }
    }
  });
};
</code></pre>
<p>The above code will take the schema and find all occurrences of <code>hidden</code>. Then, we check if it's defined in the right place and apply our custom logic to it. The logic will either remove the <code>fieldConfig</code> or the <code>type</code> from the schema if the directive was found. Otherwise, it will return the original definition and not change the schema.</p>
<h3 id="heading-the-apollo-server-plugin">The Apollo Server Plugin</h3>
<p>Our server plugin will now use <code>requestDidStart</code> lifecycle and the <code>responseForOperation</code> event. We need a way to identify if we are receiving an introspection query. For this, let's add a simple regex to check if the query contains at least one of the introspection keywords.</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> REGEX_INTROSPECTION_QUERY = <span class="hljs-regexp">/\b(__schema|__type|__typename)\b/</span>;
</code></pre>
<p>We can now identify if we receive an introspection request to our schema or if it's a normal operation without any introspection parts.</p>
<p>So, let's bring everything together and write our custom plugin to apply our directive once we receive a schema introspection:</p>
<p>First, we want to check if the plugin is being executed in the <code>production</code> environment in <code>development</code>we want full access to the schema and the playground. By returning <code>null</code>we can tell Apollo that we don't want to provide our own result for the specific query, and the execution flow should be run normally.</p>
<pre><code class="lang-typescript"><span class="hljs-comment">// only on production</span>
<span class="hljs-keyword">if</span> (!isProd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
</code></pre>
<p>Secondly, we check if the query is an actual introspection request by checking the operation name (playgrounds often send a named query called <code>IntrospectionQuery</code> to the sever) or if it includes any reserved keywords that are part of the schema introspection.</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> isIntrospectionQuery =
 ctx.request.operationName === <span class="hljs-string">'IntrospectionQuery'</span> ||
 ctx.request.query?.includes(<span class="hljs-string">'IntrospectionQuery'</span>);

<span class="hljs-keyword">const</span> hasIntrospectionParts =
 isIntrospectionQuery ||
 REGEX_INTROSPECTION_QUERY.test(ctx.request.query || <span class="hljs-string">''</span>);
</code></pre>
<p>If we determine this to be true, we take the original schema and pass it to the <code>hiddenDirectiveTransformer,</code> which will clean our schema from everything we don't want to include within the introspection result.</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> schema = hiddenDirectiveTransformer(ctx?.schema);
<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> execute({
 schema: schema,
 <span class="hljs-built_in">document</span>,
 contextValue: ctx.contextValue,
 variableValues: request.variables,
 operationName: request.operationName
});
</code></pre>
<p>The last step is executing the actual introspection request by calling the <code>execute</code> function provided by the <code>graphql</code> package.</p>
<p>Now we can create the response to the request by copying everything from the initial request and overriding the body:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">const</span> response: GraphQLResponse = {
 ...ctx.response,
 body: {
  kind: <span class="hljs-string">'single'</span>,
  singleResult: {
   ...result
  }
 }
};
</code></pre>
<p>And that's it. Piercing every part together, our plugin now looks like this:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">type</span> PluginDefinition = ApolloServerPlugin&lt;Context&gt;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> introspectionPlugin: <span class="hljs-function">(<span class="hljs-params">isProd: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> PluginDefinition = <span class="hljs-function">(<span class="hljs-params">
  isProd
</span>) =&gt;</span> ({
  <span class="hljs-keyword">async</span> requestDidStart() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-comment">// This event is fired immediately before GraphQL execution </span>
      <span class="hljs-comment">//takes place</span>
      <span class="hljs-keyword">async</span> responseForOperation(ctx) {
        <span class="hljs-comment">// only on production</span>
        <span class="hljs-keyword">if</span> (!isProd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">const</span> isIntrospectionQuery =
          ctx.request.operationName === <span class="hljs-string">'IntrospectionQuery'</span> ||
          ctx.request.query?.includes(<span class="hljs-string">'IntrospectionQuery'</span>);

        <span class="hljs-keyword">const</span> hasIntrospectionParts =
          isIntrospectionQuery ||
          REGEX_INTROSPECTION_QUERY.test(ctx.request.query || <span class="hljs-string">''</span>);
        <span class="hljs-comment">// If it's an introspection query, we need to apply the hidden </span>
        <span class="hljs-comment">// directive transformer ourself</span>
        <span class="hljs-comment">// otherwise, let Apollo handle the request by returning null</span>
        <span class="hljs-keyword">if</span> (hasIntrospectionParts) {
          <span class="hljs-keyword">const</span> { request, <span class="hljs-built_in">document</span> } = ctx;

          <span class="hljs-comment">// APPLY @hidden</span>
          <span class="hljs-keyword">const</span> schema = hiddenDirectiveTransformer(ctx?.schema);
          <span class="hljs-comment">// Executing the request </span>
          <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> execute({
            schema: schema,
            <span class="hljs-built_in">document</span>,
            contextValue: ctx.contextValue,
            variableValues: request.variables,
            operationName: request.operationName
          });

          <span class="hljs-comment">// Setting the result</span>
          <span class="hljs-keyword">const</span> response: GraphQLResponse = {
            ...ctx.response,
            body: {
              kind: <span class="hljs-string">'single'</span>,
              singleResult: {
                ...result
              }
            }
          };
          <span class="hljs-keyword">return</span> response;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    };
  }
});
</code></pre>
<p>Now we can apply our directive type definitions to our base schema and add our plugin to the Apollo Server - let's see how it works out üëÄ</p>
<h3 id="heading-lets-test-it-out">Let‚Äôs Test It Out üöÄ</h3>
<p>To check if everything works as expected, we will again use our simple schema to verify our implementation.</p>
<pre><code class="lang-graphql"><span class="hljs-keyword">type</span> Example {
 <span class="hljs-symbol">fieldA:</span> String!
 <span class="hljs-symbol">fieldB:</span> String! <span class="hljs-meta">@hidden</span>
} 

<span class="hljs-keyword">type</span> Query {
 <span class="hljs-symbol">getExampleOne:</span> Example!
 <span class="hljs-symbol">getExampleHidden:</span> Example! <span class="hljs-meta">@hidden</span>
} 

<span class="hljs-keyword">type</span> Mutation {
 mutateOnExampleHidden(<span class="hljs-symbol">input:</span> String!): Example! <span class="hljs-meta">@hidden</span>
}
</code></pre>
<p>Let's request a simple introspection query that checks for all fields on <code>query</code> and <code>mutation</code> as well as specifically requesting the <code>Example</code> type from our schema.</p>
<pre><code class="lang-graphql"><span class="hljs-keyword">query</span> {
  __schema {
    queryType {
      name
      fields {
        name
      }
    }
    mutationType {
      name
      fields {
        name
      }
    }
  }
  __type(<span class="hljs-symbol">name:</span> <span class="hljs-string">"Example"</span>) {
    fields {
      name
    }
  }
}
</code></pre>
<p>Running this in our <code>development</code> environment will return the following result:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1683896081794/c38c8cb5-3c03-45cf-a2bc-7342a861f535.png" class="image--center mx-auto" /></p>
<p>All the fields are there, even though some are annotated with <code>@hidden</code> as we are not running in production.</p>
<p>Now repeat this in our <code>production</code> environment, and we see the following result:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1683896198367/7ac9a738-055b-40c8-b8fc-e3b46c74f710.png" class="image--center mx-auto" /></p>
<p>Yeah üéâ We have successfully omitted the fields we don't want to be part of a public introspection request to our server ü™Ñ</p>
<h2 id="heading-takeaways">Takeaways</h2>
<p>Now let's revisit what we implemented here and what implications we have.</p>
<p>First, this is, by no means, a safeguard for your server. Even if we omit certain fields and types from the introspection response, they are still part of the schema and will be available normally. Rather see it as making it a little harder and not as obvious for your consumers that some <code>private</code> things exist in your schema. Overall, the best way of thinking is always that everybody can see everything in GraphQL, and you should design your schema and security following this thought.</p>
<p>Secondly, you must ensure that any reference to other definitions you have made must also be hidden. Take a look at the following code snippet:</p>
<pre><code class="lang-graphql"><span class="hljs-keyword">type</span> ThisIsHidden <span class="hljs-meta">@hidden</span> {
<span class="hljs-symbol">fieldOther:</span> String!
}

<span class="hljs-keyword">type</span> Example {
 <span class="hljs-symbol">fieldA:</span> String!
 <span class="hljs-symbol">fieldB:</span> String!
 <span class="hljs-symbol">fieldC:</span> ThisIsHidden!
} 

<span class="hljs-keyword">type</span> Query {
 <span class="hljs-symbol">getExampleOne:</span> Example!
 <span class="hljs-symbol">getExampleHidden:</span> Example! <span class="hljs-meta">@hidden</span>
} 

<span class="hljs-keyword">type</span> Mutation {
 mutateOnExampleHidden(<span class="hljs-symbol">input:</span> String!): Example! <span class="hljs-meta">@hidden</span>
}
</code></pre>
<p>If we now make an introspection query, this will fail, as we have removed the definition of <code>ThisIsHidden</code> from our schema but still referring to it in the <code>Example</code> type. Some third-party tools may break due to the missing reference. An easy fix is to add: <code>fieldC: ThisIsHidden! @hidden</code>. Still, you need to take care of this yourself.</p>
<p>Always double-check if you are not breaking other tools that are relying on your schema by carelessly using the hidden directive üôå</p>
<p>Alright, that's it about hiding things from Introspection queries to your Server - I hope you enjoyed the read üëã</p>
</div></article></div></main></div><footer class="px-5 py-20 border-t bg-slate-100 dark:bg-neutral-900 dark:border-neutral-800"><div class="container mx-auto grid grid-cols-1 gap-10 md:grid-cols-2"><div class="flex flex-col items-start col-span-1 gap-10 text-slate-500 dark:text-neutral-300"><h3 class="text-lg md:text-xl">The headless blog starter kit by Hashnode. Built with Next.js, TailwindCSS and Hashnode GraphQL APIs.</h3><div class="flex flex-row items-center gap-2 p-5 text-slate-600 bg-slate-200 rounded-xl"><p class="">Blog powered by</p><a href="#" class="flex flex-row items-center gap-1 font-semibold hover:underline"><svg class="w-5 h-5 stroke-current" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-width="1.5" d="M7.314 4.97c1.64-1.64 2.461-2.46 3.407-2.767a4.143 4.143 0 0 1 2.56 0c.946.307 1.766 1.127 3.407 2.768l2.341 2.341c1.64 1.64 2.46 2.46 2.768 3.407.27.832.27 1.728 0 2.56-.307.946-1.127 1.766-2.768 3.407l-2.343 2.343c-1.64 1.64-2.461 2.46-3.407 2.768-.832.27-1.728.27-2.56 0-.946-.307-1.766-1.127-3.407-2.768l-2.341-2.341c-1.64-1.64-2.46-2.46-2.768-3.407a4.143 4.143 0 0 1 0-2.56C2.51 9.775 3.33 8.955 4.97 7.314l2.343-2.343Z"></path><path stroke="currentColor" stroke-width="1.5" d="M15.107 12a3.107 3.107 0 1 1-6.214 0 3.107 3.107 0 0 1 6.214 0Z"></path></svg>Hashnode</a></div></div><div class="flex flex-row items-center justify-start col-span-1 gap-2 md:justify-end text-slate-600 dark:text-neutral-300"><a class="hover:underline" href="#">Privacy</a><a class="hover:underline" href="#">Terms</a><p>¬© Company 2023</p></div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"keep-parts-of-your-graphql-introspection-query-hidden","url":"https://engineering.hashnode.com/keep-parts-of-your-graphql-introspection-query-hidden","brief":"Once you have created your first schema and your GraphQL server is up and running, it makes sense to implement precautions to prevent it from being compromised by bad actors. In the context of Hashnode, our GraphQL API serves our website and blogs. T...","title":"Keep parts of your GraphQL Introspection Query hidden","publishedAt":"2023-05-24T10:00:39.246Z","coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1683820367152/f890c01d-283f-4a00-acad-34bc2d2542e4.png"},"author":{"name":"Florian Fuchs","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1675085454170/766f4dd9-9fba-4aa7-b141-ff62bba7eafe.jpeg"},"id":"646de0479098493346f6fff5","content":{"markdown":"Once you have created your first schema and your GraphQL server is up and running, it makes sense to implement precautions to prevent it from being compromised by bad actors. In the context of Hashnode, our GraphQL API serves our website and blogs. This article will explore excluding fields from an introspection request without disabling the server's discoverability feature by completely turning off the introspection queries.\n\n## The Result of Hiding Parts of the Schema on Introspection\n\nThe diagram below shows the final result of using a directive and an Apollo Server plugin to hide aspects from the incoming introspection request.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1684326033578/2eca5989-8763-4177-a1d9-65582e07d155.png align=\"center\")\n\nWe have a schema defined where multiple fields are annotated with `@hidden`. In the returned resultset of the Introspection query, we can see that all those fields are missing.\n\nLet's explore how we implemented it!\n\n## Taking a Look at GraphQL Schema Introspection\n\nGraphQL is a strongly typed query language. The schema, exposed from a GQL API, acts as a contract between the frontend and backend and defines the available operations. The server knows about the schema, as it's the place of definition. But how does the frontend get to know about the schema?\n\nThis is where one of the key features of GraphQL comes in hand: Schema introspection. Offering the introspection of a schema allows the clients to explore and learn about what's possible in a given API in terms of queries, mutations, subscriptions, fields, and types.\n\nThere are a couple of keywords to request schema introspections. A double underscore precedes all of them: `__`. A simple introspection query for all available types could look like this:\n\n```graphql\nquery {\n  __schema {\n    types {\n      name\n    }\n  }\n}\n```\n\nSounds great, right? It is, you get a kind of self-documentation for free. But what if you don't want to scream out your **whole** schema to the world? Due to the nature of GQL and the contract a schema poses, everything in your GraphQL schema will be visible to the world.\n\nHow can we hide certain aspects of our schema?\n\n* Shutting down the Introspection Query is a certain way to keep things private. This might be an option in a private API, but why would we hide the schema there? Turning off the introspection query in a public API would cause all our consumers to lose the ability to discover the schema, which is certainly not what we want. Additionally, automatic code generation is a common use case that relies on introspection.\n    \n* Removing certain fields from the introspection is another approach that may be more complex to manage but does not break every third-party consumer.\n    \n\nLet's explore how we can solve this problem by using some native GQL features as well as a specialty of Apollo Server: directives and plugins üé¨\n\n## Directives in Graphql Can Apply Custom Logic\n\nA directive in GraphQL is a decorator for parts of a schema or operation. An `@` character always precedes it. The most common and build-in directive is the `@depreacted` decorator that indicates the deprecation for a field:\n\n```graphql\ntype ExampleType {\n  oldField: String @deprecated(reason: \"Use `newField`.\")\n  newField: String\n}\n```\n\nThis shows two things:\n\n1. A directive can take an argument, e.g., `reason`.\n    \n2. A directive will always be placed after declaring a field or operation.\n    \n\nThere are multiple valid locations for a directive. For example, a directive declared with `ARGUMENT_DEFINITION` can be placed on an argument but not somewhere else within the schema.\n\n```graphql\ntype ExampleType {\n  oldField: String @argumentOnlyDirective # would throw an error \n  newField: String\n}\n```\n\nOverall, directives are neet enhancements for GQL that allow the execution of custom logic as appropriate. Things like authentication or authorization can be built easily with a directive.\n\nFor further reading, check out the [Apollo Server docs on directives](https://www.apollographql.com/docs/apollo-server/schema/directives/).\n\n## Formalizing the `@hidden` Directive\n\nIn our case, we want a directive that can be used in different places within our schema to hide things from the Introspection output. The simplest form of our directive can look something like this:\n\n```graphql\n  directive @hidden on OBJECT | FIELD_DEFINITION\n```\n\nWe want to be able to hide any `OBJECT`or `FIELD_DEFINITION`. This allows removing of various things from the schema. This can be enhanced to your own needs by adding additional valid locations.\n\n```graphql\ntype Example {\n fieldA: String!\n fieldB: String! @hidden\n} \n\ntype Query {\n getExampleOne: Example!\n getExampleHidden: Example! @hidden\n} \n\ntype Mutation {\n mutateOnExampleHidden(input: String!): Example! @hidden\n}\n```\n\nConsidering the above schema definition, our `@hidden` directive should be able to transform the schema once an introspection is requested by removing all the fields from the resultset, which are declared with the directive. The visible schema for a requesting consumer should look like this:\n\n```graphql\ntype Example {\n fieldA: String!\n} \n\ntype Query {\n getExampleOne: Example!\n}\n```\n\nCoding this out should be rather straightforward. If we find the annotation `@hidden`, we can remove the declared fields from the schema; otherwise, we return the original type.\n\n```typescript\nconst directive = getDirective(...);\n  \nif (directive) {\n return null;\n} else {\n return type;\n}\n```\n\n## Why Does the Directive Alone Not Work?\n\nExcellent, we now have a definition of our new directive and an Idea of how we want the output to be transformed. Once implemented, we can observe a weird behavior: It works on introspection but will also remove fields from the actual GraphQL results sets on incoming requests ü§Ø\n\nWhy is that?\n\nRetake a look at how we defined the directive from a custom logic point of view and consider when directives are applied.\n\nIn Apollo Server, a directive is applied by transforming the schema. So, applying the directive on server startup with the above code would remove the annotated fields from inspection and the whole schema. This is not what we want. The context provided to the transform function does not indicate the query type. Furthermore, introspection queries are handled a little differently by the Apollo Server.\n\nHow can we still achieve our goal of hiding things from the introspecting only?  \n‚û°Ô∏è Apollo plugins to the rescue üöÄ\n\n## Plugins in Apollo Server Allow You to Hook Into the Request Life Cycle\n\nApollo allows you to implement server plugins to perform custom operations in response to specific events. A plugin is a JavaScript object that implements one or more functions responding to events. Within a plugin are two major event categories: server [lifecycle events](https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#server-lifecycle-events) and [request lifecycle events](https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#request-lifecycle-events). In our case, we are interested in Request lifecycle events, as we want to respond to a certain event within the execution of an operation, e.g. a Request to our API.\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1684155854681/a15bf2fc-94c6-4a0d-979a-d8522b72e651.png align=\"center\")\n\nTaking the above flow of the request lifecycle into account, we can see an option to hook into the returned result before the actual execution starts, in that we write a plugin that will provide its result within the `responseForOperation` hook.\n\nTaking a look into the definition of the hook, we can also confirm this above observation\n\n\u003e The `responseForOperation` event is fired immediately before GraphQL execution would take place. If its return value resolves to a non-null `GraphQLResponse`, that result is used instead of executing the query. Hooks from different plugins are invoked in series, and the first non-null response is used.\n\nIn this hook, we have various information at our disposal to decide if we want the normal resolver flow to be invoked or if we want to do a kind of *early exit* without resolving the given fields:\n\n```typescript\nresponseForOperation?(\n requestContext:WithRequired\u003cGraphQLRequestContext\u003cTContext\u003e,\n 'source' | 'queryHash' | 'document' | 'operationName' |'operation'\n): Promise\u003cGraphQLResponse | null\u003e;\n```\n\nWithin the `requestContxt` we find the information about which `query` was sent to the server and the operation name, and we get our hands on the whole schema that will be used for executing the request.\n\nLet's use this to combine our custom directive with a custom plugin that will hide aspects of our schema from introspection requests.\n\n## An Implementation Tells More Than 1000 Words!\n\nOverall, we have now discovered a couple of things we can make use of:\n\n* Our directive will transform a schema and remove everything annotated with `@hidden`\n    \n* We can hook into the request execution lifecycle by providing a custom plugin\n    \n* `responseForOperation` that allows us to provide a different result and skip the normal resolver execution for a request\n    \n* Within the `requestContext` we have all the information, which is also available for the normal execution of the request, to generate our result for a request\n    \n\nThe main idea is to hook into the request execution and check if we are receiving an introspection of the schema. With the information provided by `responseForOperation` and the option to directly provided a result here, we can skip the actual execution and provide a different result. This is where we can apply our hidden directive to transform the schema and remove everything annotated with `@hidden`. We will now use this updated schema **only** if we receive an introspection for further execution of the request.\n\nLet's take a look at the implementation of the plugin and directive!\n\n### The `@hidden` Directive\n\nThe directive consists of the code snippets from above and some more checks. The result of the function we are defining here is a `transformer` that will change the schema. It takes a GraphQL schema as input and will return one.\n\n```typescript\nimport { getDirective, MapperKind, mapSchema } from '@graphql-tools/utils';\nimport { gql } from 'graphql-tag';\nimport { GraphQLSchema } from 'graphql';\n\ntype DirectiveTransformer = (schema: GraphQLSchema) =\u003e GraphQLSchema;\n\n\nexport const hiddenDirectiveTypeDefs = gql`\n  directive @hidden on OBJECT | FIELD_DEFINITION\n`;\n/**\n * This directive transformer removes all types and fields that are marked with the @hidden directive from introspection queries only\n */\nexport const hiddenDirectiveTransformer: DirectiveTransformer = (schema) =\u003e {\n  const directiveName = 'hidden';\n\n  return mapSchema(schema, {\n    [MapperKind.TYPE]: (type) =\u003e {\n      const directive = getDirective(schema, type, directiveName)?.[0];\n      if (directive) {\n        return null;\n      } else {\n        return type;\n      }\n    },\n    [MapperKind.OBJECT_FIELD]: (fieldConfig) =\u003e {\n      const directive = getDirective(schema, fieldConfig, directiveName)?.[0];\n      if (directive) {\n        return null;\n      } else {\n        return fieldConfig;\n      }\n    }\n  });\n};\n```\n\nThe above code will take the schema and find all occurrences of `hidden`. Then, we check if it's defined in the right place and apply our custom logic to it. The logic will either remove the `fieldConfig` or the `type` from the schema if the directive was found. Otherwise, it will return the original definition and not change the schema.\n\n### The Apollo Server Plugin\n\nOur server plugin will now use `requestDidStart` lifecycle and the `responseForOperation` event. We need a way to identify if we are receiving an introspection query. For this, let's add a simple regex to check if the query contains at least one of the introspection keywords.\n\n```typescript\nconst REGEX_INTROSPECTION_QUERY = /\\b(__schema|__type|__typename)\\b/;\n```\n\nWe can now identify if we receive an introspection request to our schema or if it's a normal operation without any introspection parts.\n\nSo, let's bring everything together and write our custom plugin to apply our directive once we receive a schema introspection:\n\nFirst, we want to check if the plugin is being executed in the `production` environment in `development`we want full access to the schema and the playground. By returning `null`we can tell Apollo that we don't want to provide our own result for the specific query, and the execution flow should be run normally.\n\n```typescript\n// only on production\nif (!isProd) return null;\n```\n\nSecondly, we check if the query is an actual introspection request by checking the operation name (playgrounds often send a named query called `IntrospectionQuery` to the sever) or if it includes any reserved keywords that are part of the schema introspection.\n\n```typescript\nconst isIntrospectionQuery =\n ctx.request.operationName === 'IntrospectionQuery' ||\n ctx.request.query?.includes('IntrospectionQuery');\n\nconst hasIntrospectionParts =\n isIntrospectionQuery ||\n REGEX_INTROSPECTION_QUERY.test(ctx.request.query || '');\n```\n\nIf we determine this to be true, we take the original schema and pass it to the `hiddenDirectiveTransformer,` which will clean our schema from everything we don't want to include within the introspection result.\n\n```typescript\nconst schema = hiddenDirectiveTransformer(ctx?.schema);\nconst result = await execute({\n schema: schema,\n document,\n contextValue: ctx.contextValue,\n variableValues: request.variables,\n operationName: request.operationName\n});\n```\n\nThe last step is executing the actual introspection request by calling the `execute` function provided by the `graphql` package.\n\nNow we can create the response to the request by copying everything from the initial request and overriding the body:\n\n```typescript\nconst response: GraphQLResponse = {\n ...ctx.response,\n body: {\n  kind: 'single',\n  singleResult: {\n   ...result\n  }\n }\n};\n```\n\nAnd that's it. Piercing every part together, our plugin now looks like this:\n\n```typescript\ntype PluginDefinition = ApolloServerPlugin\u003cContext\u003e;\n\nexport const introspectionPlugin: (isProd: boolean) =\u003e PluginDefinition = (\n  isProd\n) =\u003e ({\n  async requestDidStart() {\n    return {\n      // This event is fired immediately before GraphQL execution \n      //takes place\n      async responseForOperation(ctx) {\n        // only on production\n        if (!isProd) return null;\n\n        const isIntrospectionQuery =\n          ctx.request.operationName === 'IntrospectionQuery' ||\n          ctx.request.query?.includes('IntrospectionQuery');\n\n        const hasIntrospectionParts =\n          isIntrospectionQuery ||\n          REGEX_INTROSPECTION_QUERY.test(ctx.request.query || '');\n        // If it's an introspection query, we need to apply the hidden \n        // directive transformer ourself\n        // otherwise, let Apollo handle the request by returning null\n        if (hasIntrospectionParts) {\n          const { request, document } = ctx;\n\n          // APPLY @hidden\n          const schema = hiddenDirectiveTransformer(ctx?.schema);\n          // Executing the request \n          const result = await execute({\n            schema: schema,\n            document,\n            contextValue: ctx.contextValue,\n            variableValues: request.variables,\n            operationName: request.operationName\n          });\n\n          // Setting the result\n          const response: GraphQLResponse = {\n            ...ctx.response,\n            body: {\n              kind: 'single',\n              singleResult: {\n                ...result\n              }\n            }\n          };\n          return response;\n        }\n        return null;\n      }\n    };\n  }\n});\n```\n\nNow we can apply our directive type definitions to our base schema and add our plugin to the Apollo Server - let's see how it works out üëÄ\n\n### Let‚Äôs Test It Out üöÄ\n\nTo check if everything works as expected, we will again use our simple schema to verify our implementation.\n\n```graphql\ntype Example {\n fieldA: String!\n fieldB: String! @hidden\n} \n\ntype Query {\n getExampleOne: Example!\n getExampleHidden: Example! @hidden\n} \n\ntype Mutation {\n mutateOnExampleHidden(input: String!): Example! @hidden\n}\n```\n\nLet's request a simple introspection query that checks for all fields on `query` and `mutation` as well as specifically requesting the `Example` type from our schema.\n\n```graphql\nquery {\n  __schema {\n    queryType {\n      name\n      fields {\n        name\n      }\n    }\n    mutationType {\n      name\n      fields {\n        name\n      }\n    }\n  }\n  __type(name: \"Example\") {\n    fields {\n      name\n    }\n  }\n}\n```\n\nRunning this in our `development` environment will return the following result:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1683896081794/c38c8cb5-3c03-45cf-a2bc-7342a861f535.png align=\"center\")\n\nAll the fields are there, even though some are annotated with `@hidden` as we are not running in production.\n\nNow repeat this in our `production` environment, and we see the following result:\n\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1683896198367/7ac9a738-055b-40c8-b8fc-e3b46c74f710.png align=\"center\")\n\nYeah üéâ We have successfully omitted the fields we don't want to be part of a public introspection request to our server ü™Ñ\n\n## Takeaways\n\nNow let's revisit what we implemented here and what implications we have.\n\nFirst, this is, by no means, a safeguard for your server. Even if we omit certain fields and types from the introspection response, they are still part of the schema and will be available normally. Rather see it as making it a little harder and not as obvious for your consumers that some `private` things exist in your schema. Overall, the best way of thinking is always that everybody can see everything in GraphQL, and you should design your schema and security following this thought.\n\nSecondly, you must ensure that any reference to other definitions you have made must also be hidden. Take a look at the following code snippet:\n\n```graphql\ntype ThisIsHidden @hidden {\nfieldOther: String!\n}\n\ntype Example {\n fieldA: String!\n fieldB: String!\n fieldC: ThisIsHidden!\n} \n\ntype Query {\n getExampleOne: Example!\n getExampleHidden: Example! @hidden\n} \n\ntype Mutation {\n mutateOnExampleHidden(input: String!): Example! @hidden\n}\n```\n\nIf we now make an introspection query, this will fail, as we have removed the definition of `ThisIsHidden` from our schema but still referring to it in the `Example` type. Some third-party tools may break due to the missing reference. An easy fix is to add: `fieldC: ThisIsHidden! @hidden`. Still, you need to take care of this yourself.\n\nAlways double-check if you are not breaking other tools that are relying on your schema by carelessly using the hidden directive üôå\n\nAlright, that's it about hiding things from Introspection queries to your Server - I hope you enjoyed the read üëã","html":"\u003cp\u003eOnce you have created your first schema and your GraphQL server is up and running, it makes sense to implement precautions to prevent it from being compromised by bad actors. In the context of Hashnode, our GraphQL API serves our website and blogs. This article will explore excluding fields from an introspection request without disabling the server's discoverability feature by completely turning off the introspection queries.\u003c/p\u003e\n\u003ch2 id=\"heading-the-result-of-hiding-parts-of-the-schema-on-introspection\"\u003eThe Result of Hiding Parts of the Schema on Introspection\u003c/h2\u003e\n\u003cp\u003eThe diagram below shows the final result of using a directive and an Apollo Server plugin to hide aspects from the incoming introspection request.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1684326033578/2eca5989-8763-4177-a1d9-65582e07d155.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eWe have a schema defined where multiple fields are annotated with \u003ccode\u003e@hidden\u003c/code\u003e. In the returned resultset of the Introspection query, we can see that all those fields are missing.\u003c/p\u003e\n\u003cp\u003eLet's explore how we implemented it!\u003c/p\u003e\n\u003ch2 id=\"heading-taking-a-look-at-graphql-schema-introspection\"\u003eTaking a Look at GraphQL Schema Introspection\u003c/h2\u003e\n\u003cp\u003eGraphQL is a strongly typed query language. The schema, exposed from a GQL API, acts as a contract between the frontend and backend and defines the available operations. The server knows about the schema, as it's the place of definition. But how does the frontend get to know about the schema?\u003c/p\u003e\n\u003cp\u003eThis is where one of the key features of GraphQL comes in hand: Schema introspection. Offering the introspection of a schema allows the clients to explore and learn about what's possible in a given API in terms of queries, mutations, subscriptions, fields, and types.\u003c/p\u003e\n\u003cp\u003eThere are a couple of keywords to request schema introspections. A double underscore precedes all of them: \u003ccode\u003e__\u003c/code\u003e. A simple introspection query for all available types could look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e\u003cspan class=\"hljs-keyword\"\u003equery\u003c/span\u003e {\n  __schema {\n    types {\n      name\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSounds great, right? It is, you get a kind of self-documentation for free. But what if you don't want to scream out your \u003cstrong\u003ewhole\u003c/strong\u003e schema to the world? Due to the nature of GQL and the contract a schema poses, everything in your GraphQL schema will be visible to the world.\u003c/p\u003e\n\u003cp\u003eHow can we hide certain aspects of our schema?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eShutting down the Introspection Query is a certain way to keep things private. This might be an option in a private API, but why would we hide the schema there? Turning off the introspection query in a public API would cause all our consumers to lose the ability to discover the schema, which is certainly not what we want. Additionally, automatic code generation is a common use case that relies on introspection.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eRemoving certain fields from the introspection is another approach that may be more complex to manage but does not break every third-party consumer.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet's explore how we can solve this problem by using some native GQL features as well as a specialty of Apollo Server: directives and plugins üé¨\u003c/p\u003e\n\u003ch2 id=\"heading-directives-in-graphql-can-apply-custom-logic\"\u003eDirectives in Graphql Can Apply Custom Logic\u003c/h2\u003e\n\u003cp\u003eA directive in GraphQL is a decorator for parts of a schema or operation. An \u003ccode\u003e@\u003c/code\u003e character always precedes it. The most common and build-in directive is the \u003ccode\u003e@depreacted\u003c/code\u003e decorator that indicates the deprecation for a field:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e ExampleType {\n  \u003cspan class=\"hljs-symbol\"\u003eoldField:\u003c/span\u003e String \u003cspan class=\"hljs-meta\"\u003e@deprecated\u003c/span\u003e(\u003cspan class=\"hljs-symbol\"\u003ereason:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Use `newField`.\"\u003c/span\u003e)\n  \u003cspan class=\"hljs-symbol\"\u003enewField:\u003c/span\u003e String\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis shows two things:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eA directive can take an argument, e.g., \u003ccode\u003ereason\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eA directive will always be placed after declaring a field or operation.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThere are multiple valid locations for a directive. For example, a directive declared with \u003ccode\u003eARGUMENT_DEFINITION\u003c/code\u003e can be placed on an argument but not somewhere else within the schema.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e ExampleType {\n  \u003cspan class=\"hljs-symbol\"\u003eoldField:\u003c/span\u003e String \u003cspan class=\"hljs-meta\"\u003e@argumentOnlyDirective\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# would throw an error \u003c/span\u003e\n  \u003cspan class=\"hljs-symbol\"\u003enewField:\u003c/span\u003e String\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOverall, directives are neet enhancements for GQL that allow the execution of custom logic as appropriate. Things like authentication or authorization can be built easily with a directive.\u003c/p\u003e\n\u003cp\u003eFor further reading, check out the \u003ca target=\"_blank\" href=\"https://www.apollographql.com/docs/apollo-server/schema/directives/\"\u003eApollo Server docs on directives\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"heading-formalizing-the-hidden-directive\"\u003eFormalizing the \u003ccode\u003e@hidden\u003c/code\u003e Directive\u003c/h2\u003e\n\u003cp\u003eIn our case, we want a directive that can be used in different places within our schema to hide things from the Introspection output. The simplest form of our directive can look something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e  directive \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eon\u003c/span\u003e OBJECT | FIELD_DEFINITION\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe want to be able to hide any \u003ccode\u003eOBJECT\u003c/code\u003eor \u003ccode\u003eFIELD_DEFINITION\u003c/code\u003e. This allows removing of various things from the schema. This can be enhanced to your own needs by adding additional valid locations.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Example {\n \u003cspan class=\"hljs-symbol\"\u003efieldA:\u003c/span\u003e String!\n \u003cspan class=\"hljs-symbol\"\u003efieldB:\u003c/span\u003e String! \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e\n} \n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Query {\n \u003cspan class=\"hljs-symbol\"\u003egetExampleOne:\u003c/span\u003e Example!\n \u003cspan class=\"hljs-symbol\"\u003egetExampleHidden:\u003c/span\u003e Example! \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e\n} \n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Mutation {\n mutateOnExampleHidden(\u003cspan class=\"hljs-symbol\"\u003einput:\u003c/span\u003e String!): Example! \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eConsidering the above schema definition, our \u003ccode\u003e@hidden\u003c/code\u003e directive should be able to transform the schema once an introspection is requested by removing all the fields from the resultset, which are declared with the directive. The visible schema for a requesting consumer should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Example {\n \u003cspan class=\"hljs-symbol\"\u003efieldA:\u003c/span\u003e String!\n} \n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Query {\n \u003cspan class=\"hljs-symbol\"\u003egetExampleOne:\u003c/span\u003e Example!\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCoding this out should be rather straightforward. If we find the annotation \u003ccode\u003e@hidden\u003c/code\u003e, we can remove the declared fields from the schema; otherwise, we return the original type.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e directive = getDirective(...);\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (directive) {\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"heading-why-does-the-directive-alone-not-work\"\u003eWhy Does the Directive Alone Not Work?\u003c/h2\u003e\n\u003cp\u003eExcellent, we now have a definition of our new directive and an Idea of how we want the output to be transformed. Once implemented, we can observe a weird behavior: It works on introspection but will also remove fields from the actual GraphQL results sets on incoming requests ü§Ø\u003c/p\u003e\n\u003cp\u003eWhy is that?\u003c/p\u003e\n\u003cp\u003eRetake a look at how we defined the directive from a custom logic point of view and consider when directives are applied.\u003c/p\u003e\n\u003cp\u003eIn Apollo Server, a directive is applied by transforming the schema. So, applying the directive on server startup with the above code would remove the annotated fields from inspection and the whole schema. This is not what we want. The context provided to the transform function does not indicate the query type. Furthermore, introspection queries are handled a little differently by the Apollo Server.\u003c/p\u003e\n\u003cp\u003eHow can we still achieve our goal of hiding things from the introspecting only?\u003cbr /\u003e‚û°Ô∏è Apollo plugins to the rescue üöÄ\u003c/p\u003e\n\u003ch2 id=\"heading-plugins-in-apollo-server-allow-you-to-hook-into-the-request-life-cycle\"\u003ePlugins in Apollo Server Allow You to Hook Into the Request Life Cycle\u003c/h2\u003e\n\u003cp\u003eApollo allows you to implement server plugins to perform custom operations in response to specific events. A plugin is a JavaScript object that implements one or more functions responding to events. Within a plugin are two major event categories: server \u003ca target=\"_blank\" href=\"https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#server-lifecycle-events\"\u003elifecycle events\u003c/a\u003e and \u003ca target=\"_blank\" href=\"https://www.apollographql.com/docs/apollo-server/integrations/plugins-event-reference#request-lifecycle-events\"\u003erequest lifecycle events\u003c/a\u003e. In our case, we are interested in Request lifecycle events, as we want to respond to a certain event within the execution of an operation, e.g. a Request to our API.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1684155854681/a15bf2fc-94c6-4a0d-979a-d8522b72e651.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eTaking the above flow of the request lifecycle into account, we can see an option to hook into the returned result before the actual execution starts, in that we write a plugin that will provide its result within the \u003ccode\u003eresponseForOperation\u003c/code\u003e hook.\u003c/p\u003e\n\u003cp\u003eTaking a look into the definition of the hook, we can also confirm this above observation\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe \u003ccode\u003eresponseForOperation\u003c/code\u003e event is fired immediately before GraphQL execution would take place. If its return value resolves to a non-null \u003ccode\u003eGraphQLResponse\u003c/code\u003e, that result is used instead of executing the query. Hooks from different plugins are invoked in series, and the first non-null response is used.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn this hook, we have various information at our disposal to decide if we want the normal resolver flow to be invoked or if we want to do a kind of \u003cem\u003eearly exit\u003c/em\u003e without resolving the given fields:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003eresponseForOperation?(\n requestContext:WithRequired\u0026lt;GraphQLRequestContext\u0026lt;TContext\u0026gt;,\n \u003cspan class=\"hljs-string\"\u003e'source'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'queryHash'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'document'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'operationName'\u003c/span\u003e |\u003cspan class=\"hljs-string\"\u003e'operation'\u003c/span\u003e\n): \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;GraphQLResponse | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\u0026gt;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWithin the \u003ccode\u003erequestContxt\u003c/code\u003e we find the information about which \u003ccode\u003equery\u003c/code\u003e was sent to the server and the operation name, and we get our hands on the whole schema that will be used for executing the request.\u003c/p\u003e\n\u003cp\u003eLet's use this to combine our custom directive with a custom plugin that will hide aspects of our schema from introspection requests.\u003c/p\u003e\n\u003ch2 id=\"heading-an-implementation-tells-more-than-1000-words\"\u003eAn Implementation Tells More Than 1000 Words!\u003c/h2\u003e\n\u003cp\u003eOverall, we have now discovered a couple of things we can make use of:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eOur directive will transform a schema and remove everything annotated with \u003ccode\u003e@hidden\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eWe can hook into the request execution lifecycle by providing a custom plugin\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eresponseForOperation\u003c/code\u003e that allows us to provide a different result and skip the normal resolver execution for a request\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eWithin the \u003ccode\u003erequestContext\u003c/code\u003e we have all the information, which is also available for the normal execution of the request, to generate our result for a request\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe main idea is to hook into the request execution and check if we are receiving an introspection of the schema. With the information provided by \u003ccode\u003eresponseForOperation\u003c/code\u003e and the option to directly provided a result here, we can skip the actual execution and provide a different result. This is where we can apply our hidden directive to transform the schema and remove everything annotated with \u003ccode\u003e@hidden\u003c/code\u003e. We will now use this updated schema \u003cstrong\u003eonly\u003c/strong\u003e if we receive an introspection for further execution of the request.\u003c/p\u003e\n\u003cp\u003eLet's take a look at the implementation of the plugin and directive!\u003c/p\u003e\n\u003ch3 id=\"heading-the-hidden-directive\"\u003eThe \u003ccode\u003e@hidden\u003c/code\u003e Directive\u003c/h3\u003e\n\u003cp\u003eThe directive consists of the code snippets from above and some more checks. The result of the function we are defining here is a \u003ccode\u003etransformer\u003c/code\u003e that will change the schema. It takes a GraphQL schema as input and will return one.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getDirective, MapperKind, mapSchema } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@graphql-tools/utils'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { gql } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'graphql-tag'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { GraphQLSchema } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'graphql'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e DirectiveTransformer = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eschema: GraphQLSchema\u003c/span\u003e) =\u0026gt;\u003c/span\u003e GraphQLSchema;\n\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hiddenDirectiveTypeDefs = gql\u003cspan class=\"hljs-string\"\u003e`\n  directive @hidden on OBJECT | FIELD_DEFINITION\n`\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e/**\n * This directive transformer removes all types and fields that are marked with the @hidden directive from introspection queries only\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hiddenDirectiveTransformer: DirectiveTransformer = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eschema\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e directiveName = \u003cspan class=\"hljs-string\"\u003e'hidden'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e mapSchema(schema, {\n    [MapperKind.TYPE]: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e directive = getDirective(schema, \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e, directiveName)?.[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (directive) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e;\n      }\n    },\n    [MapperKind.OBJECT_FIELD]: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003efieldConfig\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e directive = getDirective(schema, fieldConfig, directiveName)?.[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (directive) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fieldConfig;\n      }\n    }\n  });\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe above code will take the schema and find all occurrences of \u003ccode\u003ehidden\u003c/code\u003e. Then, we check if it's defined in the right place and apply our custom logic to it. The logic will either remove the \u003ccode\u003efieldConfig\u003c/code\u003e or the \u003ccode\u003etype\u003c/code\u003e from the schema if the directive was found. Otherwise, it will return the original definition and not change the schema.\u003c/p\u003e\n\u003ch3 id=\"heading-the-apollo-server-plugin\"\u003eThe Apollo Server Plugin\u003c/h3\u003e\n\u003cp\u003eOur server plugin will now use \u003ccode\u003erequestDidStart\u003c/code\u003e lifecycle and the \u003ccode\u003eresponseForOperation\u003c/code\u003e event. We need a way to identify if we are receiving an introspection query. For this, let's add a simple regex to check if the query contains at least one of the introspection keywords.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e REGEX_INTROSPECTION_QUERY = \u003cspan class=\"hljs-regexp\"\u003e/\\b(__schema|__type|__typename)\\b/\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can now identify if we receive an introspection request to our schema or if it's a normal operation without any introspection parts.\u003c/p\u003e\n\u003cp\u003eSo, let's bring everything together and write our custom plugin to apply our directive once we receive a schema introspection:\u003c/p\u003e\n\u003cp\u003eFirst, we want to check if the plugin is being executed in the \u003ccode\u003eproduction\u003c/code\u003e environment in \u003ccode\u003edevelopment\u003c/code\u003ewe want full access to the schema and the playground. By returning \u003ccode\u003enull\u003c/code\u003ewe can tell Apollo that we don't want to provide our own result for the specific query, and the execution flow should be run normally.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// only on production\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isProd) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSecondly, we check if the query is an actual introspection request by checking the operation name (playgrounds often send a named query called \u003ccode\u003eIntrospectionQuery\u003c/code\u003e to the sever) or if it includes any reserved keywords that are part of the schema introspection.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isIntrospectionQuery =\n ctx.request.operationName === \u003cspan class=\"hljs-string\"\u003e'IntrospectionQuery'\u003c/span\u003e ||\n ctx.request.query?.includes(\u003cspan class=\"hljs-string\"\u003e'IntrospectionQuery'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hasIntrospectionParts =\n isIntrospectionQuery ||\n REGEX_INTROSPECTION_QUERY.test(ctx.request.query || \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we determine this to be true, we take the original schema and pass it to the \u003ccode\u003ehiddenDirectiveTransformer,\u003c/code\u003e which will clean our schema from everything we don't want to include within the introspection result.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e schema = hiddenDirectiveTransformer(ctx?.schema);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e execute({\n schema: schema,\n \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e,\n contextValue: ctx.contextValue,\n variableValues: request.variables,\n operationName: request.operationName\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe last step is executing the actual introspection request by calling the \u003ccode\u003eexecute\u003c/code\u003e function provided by the \u003ccode\u003egraphql\u003c/code\u003e package.\u003c/p\u003e\n\u003cp\u003eNow we can create the response to the request by copying everything from the initial request and overriding the body:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response: GraphQLResponse = {\n ...ctx.response,\n body: {\n  kind: \u003cspan class=\"hljs-string\"\u003e'single'\u003c/span\u003e,\n  singleResult: {\n   ...result\n  }\n }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd that's it. Piercing every part together, our plugin now looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e PluginDefinition = ApolloServerPlugin\u0026lt;Context\u0026gt;;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e introspectionPlugin: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eisProd: \u003cspan class=\"hljs-built_in\"\u003eboolean\u003c/span\u003e\u003c/span\u003e) =\u0026gt;\u003c/span\u003e PluginDefinition = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\n  isProd\n\u003c/span\u003e) =\u0026gt;\u003c/span\u003e ({\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e requestDidStart() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// This event is fired immediately before GraphQL execution \u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e//takes place\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e responseForOperation(ctx) {\n        \u003cspan class=\"hljs-comment\"\u003e// only on production\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isProd) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isIntrospectionQuery =\n          ctx.request.operationName === \u003cspan class=\"hljs-string\"\u003e'IntrospectionQuery'\u003c/span\u003e ||\n          ctx.request.query?.includes(\u003cspan class=\"hljs-string\"\u003e'IntrospectionQuery'\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hasIntrospectionParts =\n          isIntrospectionQuery ||\n          REGEX_INTROSPECTION_QUERY.test(ctx.request.query || \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n        \u003cspan class=\"hljs-comment\"\u003e// If it's an introspection query, we need to apply the hidden \u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// directive transformer ourself\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// otherwise, let Apollo handle the request by returning null\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (hasIntrospectionParts) {\n          \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { request, \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e } = ctx;\n\n          \u003cspan class=\"hljs-comment\"\u003e// APPLY @hidden\u003c/span\u003e\n          \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e schema = hiddenDirectiveTransformer(ctx?.schema);\n          \u003cspan class=\"hljs-comment\"\u003e// Executing the request \u003c/span\u003e\n          \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e execute({\n            schema: schema,\n            \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e,\n            contextValue: ctx.contextValue,\n            variableValues: request.variables,\n            operationName: request.operationName\n          });\n\n          \u003cspan class=\"hljs-comment\"\u003e// Setting the result\u003c/span\u003e\n          \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response: GraphQLResponse = {\n            ...ctx.response,\n            body: {\n              kind: \u003cspan class=\"hljs-string\"\u003e'single'\u003c/span\u003e,\n              singleResult: {\n                ...result\n              }\n            }\n          };\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response;\n        }\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n      }\n    };\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we can apply our directive type definitions to our base schema and add our plugin to the Apollo Server - let's see how it works out üëÄ\u003c/p\u003e\n\u003ch3 id=\"heading-lets-test-it-out\"\u003eLet‚Äôs Test It Out üöÄ\u003c/h3\u003e\n\u003cp\u003eTo check if everything works as expected, we will again use our simple schema to verify our implementation.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Example {\n \u003cspan class=\"hljs-symbol\"\u003efieldA:\u003c/span\u003e String!\n \u003cspan class=\"hljs-symbol\"\u003efieldB:\u003c/span\u003e String! \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e\n} \n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Query {\n \u003cspan class=\"hljs-symbol\"\u003egetExampleOne:\u003c/span\u003e Example!\n \u003cspan class=\"hljs-symbol\"\u003egetExampleHidden:\u003c/span\u003e Example! \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e\n} \n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Mutation {\n mutateOnExampleHidden(\u003cspan class=\"hljs-symbol\"\u003einput:\u003c/span\u003e String!): Example! \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's request a simple introspection query that checks for all fields on \u003ccode\u003equery\u003c/code\u003e and \u003ccode\u003emutation\u003c/code\u003e as well as specifically requesting the \u003ccode\u003eExample\u003c/code\u003e type from our schema.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e\u003cspan class=\"hljs-keyword\"\u003equery\u003c/span\u003e {\n  __schema {\n    queryType {\n      name\n      fields {\n        name\n      }\n    }\n    mutationType {\n      name\n      fields {\n        name\n      }\n    }\n  }\n  __type(\u003cspan class=\"hljs-symbol\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Example\"\u003c/span\u003e) {\n    fields {\n      name\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRunning this in our \u003ccode\u003edevelopment\u003c/code\u003e environment will return the following result:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1683896081794/c38c8cb5-3c03-45cf-a2bc-7342a861f535.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eAll the fields are there, even though some are annotated with \u003ccode\u003e@hidden\u003c/code\u003e as we are not running in production.\u003c/p\u003e\n\u003cp\u003eNow repeat this in our \u003ccode\u003eproduction\u003c/code\u003e environment, and we see the following result:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1683896198367/7ac9a738-055b-40c8-b8fc-e3b46c74f710.png\" alt class=\"image--center mx-auto\" /\u003e\u003c/p\u003e\n\u003cp\u003eYeah üéâ We have successfully omitted the fields we don't want to be part of a public introspection request to our server ü™Ñ\u003c/p\u003e\n\u003ch2 id=\"heading-takeaways\"\u003eTakeaways\u003c/h2\u003e\n\u003cp\u003eNow let's revisit what we implemented here and what implications we have.\u003c/p\u003e\n\u003cp\u003eFirst, this is, by no means, a safeguard for your server. Even if we omit certain fields and types from the introspection response, they are still part of the schema and will be available normally. Rather see it as making it a little harder and not as obvious for your consumers that some \u003ccode\u003eprivate\u003c/code\u003e things exist in your schema. Overall, the best way of thinking is always that everybody can see everything in GraphQL, and you should design your schema and security following this thought.\u003c/p\u003e\n\u003cp\u003eSecondly, you must ensure that any reference to other definitions you have made must also be hidden. Take a look at the following code snippet:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"lang-graphql\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e ThisIsHidden \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e {\n\u003cspan class=\"hljs-symbol\"\u003efieldOther:\u003c/span\u003e String!\n}\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Example {\n \u003cspan class=\"hljs-symbol\"\u003efieldA:\u003c/span\u003e String!\n \u003cspan class=\"hljs-symbol\"\u003efieldB:\u003c/span\u003e String!\n \u003cspan class=\"hljs-symbol\"\u003efieldC:\u003c/span\u003e ThisIsHidden!\n} \n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Query {\n \u003cspan class=\"hljs-symbol\"\u003egetExampleOne:\u003c/span\u003e Example!\n \u003cspan class=\"hljs-symbol\"\u003egetExampleHidden:\u003c/span\u003e Example! \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e\n} \n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Mutation {\n mutateOnExampleHidden(\u003cspan class=\"hljs-symbol\"\u003einput:\u003c/span\u003e String!): Example! \u003cspan class=\"hljs-meta\"\u003e@hidden\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we now make an introspection query, this will fail, as we have removed the definition of \u003ccode\u003eThisIsHidden\u003c/code\u003e from our schema but still referring to it in the \u003ccode\u003eExample\u003c/code\u003e type. Some third-party tools may break due to the missing reference. An easy fix is to add: \u003ccode\u003efieldC: ThisIsHidden! @hidden\u003c/code\u003e. Still, you need to take care of this yourself.\u003c/p\u003e\n\u003cp\u003eAlways double-check if you are not breaking other tools that are relying on your schema by carelessly using the hidden directive üôå\u003c/p\u003e\n\u003cp\u003eAlright, that's it about hiding things from Introspection queries to your Server - I hope you enjoyed the read üëã\u003c/p\u003e\n"},"ogMetaData":{"image":"https://cdn.hashnode.com/res/hashnode/image/upload/v1683897207381/cdd07204-4840-4835-a506-653677be4e3b.png"}}},"__N_SSG":true},"page":"/[slug]","query":{"slug":"keep-parts-of-your-graphql-introspection-query-hidden"},"buildId":"0y8ML8Ut1GKcfVwKpwMCT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>